<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>凤凰架构笔记摘要 | 酌客的个人博客</title><meta name="author" content="酌客"><meta name="copyright" content="酌客"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="凤凰架构笔记  什么是“凤凰架构”  这其中的关键点便是承认细胞等这些零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中一定会有其后代的出现，重新代替该零部件的作用，以维持系统的整体稳定。在这个微生态里，每一个部件都可以看作一只不死鸟（Phoenix），它会老迈，而之后又能涅槃重生。   只要在整体架构设计有恰当的、自动化的错误熔断、服务淘汰和重建的机制，在系统外部来观">
<meta property="og:type" content="article">
<meta property="og:title" content="凤凰架构笔记摘要">
<meta property="og:url" content="http://example.com/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="酌客的个人博客">
<meta property="og:description" content="凤凰架构笔记  什么是“凤凰架构”  这其中的关键点便是承认细胞等这些零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中一定会有其后代的出现，重新代替该零部件的作用，以维持系统的整体稳定。在这个微生态里，每一个部件都可以看作一只不死鸟（Phoenix），它会老迈，而之后又能涅槃重生。   只要在整体架构设计有恰当的、自动化的错误熔断、服务淘汰和重建的机制，在系统外部来观">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://icyfenix.cn/images//logo-color.png">
<meta property="article:published_time" content="2021-11-30T16:02:15.000Z">
<meta property="article:modified_time" content="2022-06-20T16:02:03.083Z">
<meta property="article:author" content="酌客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://icyfenix.cn/images//logo-color.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/GayHub1/images/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-21 00:02:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/GayHub1/images/flush.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/jpg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/qiandao/"><i class="fa-fw fas fa-calendar-check"></i><span> 签到</span></a></li><li><a class="site-page" href="/oneDrive"><i class="fa-fw fa fa-file"></i><span> 个人网盘</span></a></li><li><a class="site-page" href="/pyadmin"><i class="fa-fw fas fa-database"></i><span> MyAdmin</span></a></li><li><a class="site-page" href="/rsshub"><i class="fa-fw fas fa-rss-square"></i><span> RSSHUB</span></a></li><li><a class="site-page" href="/ttrss"><i class="fa-fw fas fa-book-reader"></i><span> TTRSS</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://icyfenix.cn/images//logo-color.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">酌客的个人博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/qiandao/"><i class="fa-fw fas fa-calendar-check"></i><span> 签到</span></a></li><li><a class="site-page" href="/oneDrive"><i class="fa-fw fa fa-file"></i><span> 个人网盘</span></a></li><li><a class="site-page" href="/pyadmin"><i class="fa-fw fas fa-database"></i><span> MyAdmin</span></a></li><li><a class="site-page" href="/rsshub"><i class="fa-fw fas fa-rss-square"></i><span> RSSHUB</span></a></li><li><a class="site-page" href="/ttrss"><i class="fa-fw fas fa-book-reader"></i><span> TTRSS</span></a></li></ul></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">凤凰架构笔记摘要</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-30T16:02:15.000Z" title="发表于 2021-12-01 00:02:15">2021-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T16:02:03.083Z" title="更新于 2022-06-21 00:02:03">2022-06-21</time></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="凤凰架构笔记"><a class="markdownIt-Anchor" href="#凤凰架构笔记"></a> 凤凰架构笔记</h1>
<h2 id="什么是凤凰架构"><a class="markdownIt-Anchor" href="#什么是凤凰架构"></a> 什么是“凤凰架构”</h2>
<blockquote>
<p>这其中的关键点便是承认细胞等这些零部件可能会出错，某个具体的零部件可能会崩溃消亡，但在存续生命的微生态系统中一定会有其后代的出现，重新代替该零部件的作用，以维持系统的整体稳定。在这个微生态里，每一个部件都可以看作一只不死鸟（Phoenix），它会老迈，而之后又能涅槃重生。</p>
</blockquote>
<blockquote>
<p>只要在整体架构设计有恰当的、自动化的错误熔断、服务淘汰和重建的机制，在系统外部来观察，整体上仍然有可能表现出稳定和健壮的服务能力。</p>
</blockquote>
<p>将一个系统看作是一个像人一样的生物。每一刻内部都有细胞老去凋零，也有新细胞的诞生 ，将细胞（部件）的“死去“看作是正常生理过程，并为之设计恰当的容错机制，使得内部的错误得到处理，在内部这种不断迭代情况下，从整体上看依旧具有健壮性。</p>
<h2 id="演进中的架构"><a class="markdownIt-Anchor" href="#演进中的架构"></a> <strong>演进中的架构</strong></h2>
<h3 id="原始分布式时代"><a class="markdownIt-Anchor" href="#原始分布式时代"></a> 原始分布式时代</h3>
<p>探索过程中的产物</p>
<ul>
<li>NCA是未来远程服务调用的雏形</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Andrew_File_System">AFS 文件系统</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos 协议</a>服务认证和访问控制的基础性协议</li>
<li>DCE规范( 包含 RPC  DFS等等)</li>
</ul>
<p>失败的原因</p>
<ul>
<li>机器硬件条件下性能上的差异</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">摩尔定律</a>稳定发挥作用</li>
<li>分布式架构尚未成熟</li>
</ul>
<blockquote>
<p>“如同本地调用一般简单透明的”分布式系统这个目标，是软件开发者对分布式系统最初的美好愿景</p>
</blockquote>
<p>原始的分布式时代比我猜想的要早太多太多，而且怀揣着美好的愿景对分布式进行了比较全面的尝试探索。</p>
<h3 id="单体巨石系统时代"><a class="markdownIt-Anchor" href="#单体巨石系统时代"></a> 单体(巨石)系统时代</h3>
<p>非缺点</p>
<ul>
<li>单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A">进程间通信</a>（Inter-Process Communication，IPC。</li>
<li>在纵向分层上完全不会展露出丝毫的弱势。</li>
<li>在以横向扩展（Scale Horizontally）的上可以，在负载均衡器之后同时部署若干个相同的单体系统副本(多个 JAR、WAR、DLL、Assembly 或者其他模块格式来构成)，以达到分摊流量压力的效果。</li>
</ul>
<p>缺点</p>
<ul>
<li>隔离（难以阻断错误传播）与自治能力的欠缺</li>
<li>可维护性的欠缺（修改缺陷往往需要制定专门的停机更新计划，做灰度发布、A/B 测试也相对更复杂。）</li>
<li>无法达到技术异构</li>
<li>单体系统很难兼容“<a target="_blank" rel="noopener" href="https://icyfenix.cn/introduction/about-the-fenix-project.html#%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B">Phoenix</a>”的特性。</li>
</ul>
<blockquote>
<p>单体系统很难兼容“<a target="_blank" rel="noopener" href="https://icyfenix.cn/introduction/about-the-fenix-project.html#%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B">Phoenix</a>”的特性。这种架构风格潜在的观念是希望系统的每一个部件，每一处代码都尽量可靠，靠不出或少出缺陷来构建可靠系统。然而战术层面再优秀，也很难弥补战略层面的不足，单体靠高质量来保证高可靠性的思路，在小规模软件上还能运作良好，但系统规模越大，交付一个可靠的单体系统就变得越来越具有挑战性。如本书的前言开篇《<a target="_blank" rel="noopener" href="https://icyfenix.cn/introduction/about-the-fenix-project.html">什么是&quot;凤凰架构&quot;</a>》所说，正是随着软件架构演进，构筑可靠系统从“追求尽量不出错”，到正视“出错是必然”的观念转变，才是微服务架构得以挑战并逐步开始取代运作了数十年的单体架构的底气所在。</p>
</blockquote>
<p>单体架构并不是完全是缺点，只有在项目足够复杂成为一个“<strong>大型的</strong>单体系统”，项目开发人员较多时，对项目可靠性，可维护性具有一定要求时，使用分布式系统才具体有意义。</p>
<h3 id="soa时代"><a class="markdownIt-Anchor" href="#soa时代"></a> SOA时代</h3>
<blockquote>
<p>SOA 架构（Service-Oriented Architecture）面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。</p>
</blockquote>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Information_silo">烟囱式架构</a>（Information Silo Architecture）：信息烟囱又名信息孤岛（Information Island），使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。它指的是一种<strong>完全不与其他相关信息系统进行互操作或者协调工作</strong>的设计模式。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microkernel">微内核架构</a>（Microkernel Architecture）：微内核架构也被称为插件式架构（Plug-in Architecture）。将这些主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel，也称为 Core System），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性，即微内核架构，如图 1-2 所示。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event-driven_architecture">事件驱动架构</a>（Event-Driven Architecture）：为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道（Event Queues）每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动</p>
</li>
</ul>
<p>SOA</p>
<p>“更具体”体现在尽管 SOA 本身还是属抽象概念,可以称为一套软件设计的基础平台了。有清晰软件设计的指导原则，譬如服务的封装性、自治、松耦合、可重用、可组合、无状态，等等；若仅从技术可行性这一个角度来评判的话，SOA 可以算是成功地解决了分布式环境下出现的主要技术问题。</p>
<ul>
<li>明确了采用 SOAP 作为远程调用的协议，依靠 SOAP 协议族（WSDL、UDDI 和一大票 WS-*协议）来完成服务的发布、发现和治理；</li>
<li>利用一个被称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF">企业服务总线</a>（Enterprise Service Bus，ESB）的消息管道来实现各个子系统之间的通信交互</li>
<li>使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">服务数据对象</a>（Service Data Object，SDO）来访问和表示数据</li>
<li>使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84">服务组件架构</a>（Service Component Architecture，SCA）来定义服务封装的形式和服务运行的容器</li>
</ul>
<p>“更系统”指的是 SOA 的宏大理想，SOA 不仅关注技术，还关注研发过程中涉及到的需求、管理、流程和组织。写出符合客户需求的软件会像写八股文一样有迹可循、有法可依.</p>
<p>SOAP 协议被逐渐边缘化的本质原因：过于严格的规范定义带来<strong>过度的复杂性</strong>。</p>
<p>软件架构从烟囱式架构到事件驱动,再到后来的SOA中ESB~ 有一个很明显的痛点就是在一步一步地完善架构之间组件的信息的传递交互，这点也是跟单体比较区别大的点。另外到SOA时代也进行了更加全面的探索。不过很多组件之前…几乎没有听闻，从功能性来看跟工作中接触的很多微服务组件几乎相同的功能，似乎技术的迭代更应该倾向于减少单个组件的复杂性？</p>
<h3 id="微服务时代"><a class="markdownIt-Anchor" href="#微服务时代"></a> 微服务时代</h3>
<blockquote>
<p>微服务架构（Microservices）</p>
<p>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>
</blockquote>
<p>微服务的九个核心的业务与技术特征</p>
<ul>
<li><strong>围绕业务能力构建</strong> 有怎样结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。</li>
<li>**分散治理 **微服务更加强调的是确实有必要技术异构时，应能够有选择“不统一”的权利</li>
<li><strong>通过服务来实现独立自治的组件</strong> 为组件带来隔离与自治能力</li>
<li><strong>产品化思维</strong> 避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。在微服务下，要求开发团队中每个人都具有产品化思维，关心整个产品的全部方面是具有可行性的。</li>
<li><strong>数据去中心化</strong> 微服务明确地提倡数据应该按领域分散管理、更新、维护、存储 同一个数据实体在不同服务的视角里，它的抽象形态往往也是不同的。</li>
<li><strong>强终端弱管道</strong> 如果服务需要额外通信能力，就应该在服务自己的 Endpoint 上解决，而不是在通信管道上一揽子处理。微服务提倡类似于经典 UNIX 过滤器那样简单直接的通信方式，RESTful 风格的通信在微服务中会是更加合适的选择。</li>
<li><strong>容错性设计</strong> 不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实.，要求在微服务的设计中，有自动的机制对其依赖的服务能够进行<strong>快速故障检测</strong>，在持续出错的时候进行<strong>隔离</strong>，在服务恢复的时候重新联通。可靠系统完全可能由会出错的服务组成，这是微服务最大的价值所在.</li>
<li><strong>演进式设计</strong>（Evolutionary Design）。容错性设计承认服务会出错，演进式设计则是承认服务会被<strong>报废淘汰</strong>。</li>
<li><strong>基础设施自动化</strong>（Infrastructure Automation）。微服务下运维的对象比起单体架构要有数量级的增长，使用微服务的团队更加依赖于基础设施的自动化</li>
</ul>
<p>微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”。在微服务中不再会有统一的解决方案，需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。</p>
<p>技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难症的困境之中。</p>
<p><strong>微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。</strong></p>
<p>从SOA到微服务~从一个复杂的技术标准到开发自由的多种多样解决方案的微服务生态圈，减少了开发过程的繁琐却对于技术的选型权衡利弊有了更高的要求。</p>
<h3 id="后微服务时代"><a class="markdownIt-Anchor" href="#后微服务时代"></a> 后微服务时代</h3>
<p>Kubernetes 登基加冕是容器发展中一个时代的终章，也将是软件架构发展下一个纪元的开端。</p>
<p>传统 Spring Cloud 与 Kubernetes 提供的解决方案对比</p>
<table>
<thead>
<tr>
<th></th>
<th>Kubernetes</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody>
<tr>
<td>弹性伸缩</td>
<td>Autoscaling</td>
<td>N/A</td>
</tr>
<tr>
<td>服务发现</td>
<td>KubeDNS / CoreDNS</td>
<td>Spring Cloud Eureka</td>
</tr>
<tr>
<td>配置中心</td>
<td>ConfigMap / Secret</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务网关</td>
<td>Ingress Controller</td>
<td>Spring Cloud Zuul</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Load Balancer</td>
<td>Spring Cloud Ribbon</td>
</tr>
<tr>
<td>服务安全</td>
<td>RBAC API</td>
<td>Spring Cloud Security</td>
</tr>
<tr>
<td>跟踪监控</td>
<td>Metrics API / Dashboard</td>
<td>Spring Cloud Turbine</td>
</tr>
<tr>
<td>降级熔断</td>
<td>N/A</td>
<td>Spring Cloud Hystrix</td>
</tr>
</tbody>
</table>
<p>从软件层面独力应对分布式架构所带来的各种问题，发展到应用代码与基础设施软、硬一体，合力应对架构问题的时代，现在常被媒体冠以“云原生”这个颇为抽象的名字加以宣传。云原生时代与此前微服务时代中追求的目标并没有本质改变，在服务架构演进的历史进程中，笔者更愿意称其为“后微服务时代”。</p>
<p>Kubernetes 成为容器战争胜利者标志着后微服务时代的开端，但 Kubernetes 仍然没有能够完美解决全部的分布式问题——“不完美”的意思是，仅从功能上看，单纯的 Kubernetes 反而不如之前的 Spring Cloud 方案。这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中确实很难精细化地处理。</p>
<p>基础设施是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控。</p>
<p>虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Service_mesh">服务网格</a>”（Service Mesh）的“边车代理模式”（Sidecar Proxy）在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力。</p>
<p>服务网格将会成为微服务之间通信交互的主流模式，把“选择什么通信协议”、“怎样调度流量”、“如何认证授权”之类的技术问题隔离于程序代码之外，取代今天 Spring Cloud 全家桶中大部分组件的功能，微服务只需要考虑业务本身的逻辑，这才是最理想的<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes">Smart Endpoints</a>解决方案。</p>
<p><strong>业务与技术完全分离，远程与本地完全透明，也许这就是最好的时代了吧？</strong></p>
<p>从微服务到后微服务时代，以虚拟化容器设备让软硬界限模糊，提供的新的服务之间管理方式，业务于技术完全分离，之间的跨越不亚于从先前看的单体到微服务的进程层次的差距。又是一种质的改变~~ 。</p>
<h3 id="无服务时代"><a class="markdownIt-Anchor" href="#无服务时代"></a> 无服务时代</h3>
<blockquote>
<p>如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点。</p>
</blockquote>
<p>无服务现在还没有一个特别权威的“官方”定义，但它的概念并没有前面各种架构那么复杂，本来无服务也是以“简单”为主要卖点的，它只涉及两块内容：后端设施（Backend）和函数（Function）。</p>
<ul>
<li><strong>后端设施</strong>是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）。</li>
<li><strong>函数</strong>是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）</li>
</ul>
<p>无服务的愿景是让开发者只需要纯粹地关注业务，不需要考虑技术组件只涉及两块内容：后端设施（Backend）和函数（Function）。</p>
<ul>
<li><strong>后端设施</strong>是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，</li>
<li><strong>函数</strong>是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端.</li>
</ul>
<p>优点</p>
<ul>
<li>不需要考虑技术组件，技术组件是现成的</li>
<li>不需要考虑如何部署，部署过程完全是托管到云端的，</li>
<li>不需要考虑算力，算力可以认为是无限的；</li>
<li>不需要操心运维，维护系统持续平稳运行是云计算服务商的责任</li>
</ul>
<p>缺点</p>
<p>函数不便依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能太好。函数不便依赖服务端状态，也导致了函数会有冷启动时间，响应的性能不可能太好</p>
<p>多种架构风格将会融合互补，“分布式”与“不分布式”的边界将逐渐模糊，两条路线在云端的数据中心中交汇。</p>
<h2 id="架构师的视角"><a class="markdownIt-Anchor" href="#架构师的视角"></a> 架构师的视角</h2>
<h3 id="rpc访问远程服务"><a class="markdownIt-Anchor" href="#rpc访问远程服务"></a> RPC（访问远程服务）</h3>
<p>RPC 出现的最初目的，就是<strong>为了让计算机能够跟调用本地方法一样去调用远程方法</strong>.</p>
<p>两个进程之间如何交换数据？</p>
<ul>
<li>
<p><strong>管道</strong>（Pipe）或者<strong>具名管道</strong>（Named Pipe）管道类似于两个进程间的桥梁，可通过管道在进程间传递少量的字符流或字节流。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>信号</strong>（Signal）：信号用于通知目标进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程自身。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 pid</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>信号量</strong>（Semaphore）：信号量用于两个进程之间同步协作手段，它相当于操作系统提供的一个特殊变量，程序可以在上面进行<code>wait()</code>和<code>notify()</code>操作。</p>
</li>
<li>
<p><strong>消息队列</strong>（Message Queue）</p>
</li>
<li>
<p><strong>共享内存</strong></p>
</li>
<li>
<p><strong>套接字接口</strong>（Socket）</p>
<p>通信的成本</p>
</li>
</ul>
<p>这种基于套接字接口的通信方式透明的调用形式却反而造成了程序员误以为<strong>通信是无成本的假象</strong>，因而被滥用以致于显著降低了分布式系统的性能。本地调用与远程调用当做一样处理，这是犯了方向性的错误，把系统间的调用做成透明，反而会增加程序员工作的复杂度。</p>
<p>网络编程中经常被忽略的八大问题</p>
<ul>
<li>网络是可靠的。</li>
<li>延迟是不存在的。</li>
<li>带宽是无限的。</li>
<li>网络是安全的。</li>
<li>拓扑结构是一成不变的。</li>
<li>总会有一个管理员。</li>
<li>不必考虑传输成本。</li>
<li>网络是同质化的。</li>
</ul>
<p>RPC 应该是一种高层次的或者说<strong>语言层次</strong>的特征，而不是像 IPC 那样，是低层次的或者说系统层次的特征成为工业界、学术界的主流观点。</p>
<blockquote>
<p>远程服务调用是指位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的方式使用带宽有限的信道来传输程序控制信息。</p>
</blockquote>
<p>RPC 协议解决三个基本问题</p>
<ul>
<li><strong>如何表示数据</strong>：将交互双方所涉及的数据转换为某种事先约定好的中立数据流格式来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，（序列化与反序列化）</li>
<li><strong>如何传递数据</strong>：如何通过网络，在两个服务的 Endpoint 之间相互操作、交换数据（应用层协议）。<strong>两个服务交互不是只扔个序列化数据流来表示参数和结果就行的</strong>，许多在此之外信息，譬如异常、超时、安全、认证、授权、事务，等等，都可能产生双方需要交换信息的需求。</li>
<li><strong>如何确定方法</strong>：一套语言无关的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interface_description_language">接口描述语言</a> （没想到UUID是这样出现的）</li>
</ul>
<p>统一的的RPC</p>
<blockquote>
<p>但无奈 CORBA 本身设计得实在是太过于啰嗦繁琐，甚至有些规定简直到了荒谬的程度——写一个对象请求代理（ORB，这是 CORBA 中的核心概念）大概要 200 行代码，其中大概有 170 行都是纯粹无用的废话——这句带有鞭尸性质的得罪人的评价不是笔者写的，是 CORBA 的首席科学家 Michi Henning 在文章《<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/1142031.1142044">The Rise and Fall of CORBA</a>》的愤怒批评。另一方面，为 CORBA 制定规范的专家逐渐脱离实际，做出 CORBA 规范晦涩难懂，各家语言的厂商都有自己的解读，结果各门语言最终出来的 CORBA 实现互不兼容，实在是对 CORBA 号称支持众多异构语言的莫大讽刺。</p>
</blockquote>
<p>这段看着笑到我了~</p>
<p>CORBA ：支持多种编程语言，由多家软件提供商共同参与的分布式规范;本身设计得实在是太过于<strong>啰嗦繁琐</strong></p>
<p>Web Service:数据交互都包含大量的冗余信息，性能奇差。过于严谨。贪婪。</p>
<p>那些面向透明的、简单的 RPC 协议要么依赖于操作系统，要么依赖于特定语言，总有一些先天约束；那些面向通用的、普适的 RPC 协议；如 CORBA，就无法逃过使用复杂性的困扰，而那些意图通过技术手段来屏蔽复杂性的 RPC 协议，如 Web Service，又不免受到性能问题的束缚。简单、普适、高性能这三点，似乎真的难以同时满足。</p>
<p>分裂的 RPC</p>
<p>由于一直没有一个同时满足以上三点的“完美 RPC 协议”出现，所以远程服务器调用这个小小的领域里，逐渐进入了群雄混战、百家争鸣的战国时代</p>
<p>发展方向</p>
<ul>
<li>朝着<strong>面向对象</strong>发展</li>
<li>朝着<strong>性能</strong>发展 （序列化效率和信息密度） 信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低</li>
<li>朝着<strong>简化</strong>发展</li>
</ul>
<p>到了最近几年，RPC 框架有明显的朝着更高层次（不仅仅负责调用远程服务，还管理远程服务）与插件化方向发展的趋势，不再追求独立地解决 RPC 的全部三个问题（表示数据、传递数据、表示方法），而是将一部分功能设计成扩展点，让用户自己去选择。<strong>框架聚焦于提供核心的、更高层次的能力</strong>，譬如提供负载均衡、服务注册、可观察性等方面的支持。</p>
<h3 id="rest-设计风格"><a class="markdownIt-Anchor" href="#rest-设计风格"></a> REST 设计风格</h3>
<p>REST 与 RPC 在思想上差异的核心是抽象的目标不一样，即<strong>面向资源</strong>的编程思想与面向过程的编程思想两者之间的区别。</p>
<p>“REST”（<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer）实际上是“HTT”（<strong>H</strong>yper<strong>t</strong>ext <strong>T</strong>ransfer）的进一步抽象，两者就如同接口与实现类的关系一般.</p>
<p>REST 中关键概念</p>
<ul>
<li><strong>资源</strong> 譬如你现在正在阅读一篇名为《REST 设计风格》的文章，这篇文章的内容本身（你可以将其理解为其蕴含的信息、数据）我们称之为“资源”。无论你是购买的书籍、是在浏览器看的网页、是打印出来看的文稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一份“资源”。</li>
<li><strong>表征</strong>  当你通过电脑浏览器阅读此文章时，浏览器向服务端发出请求“我需要这个资源的 HTML 格式”，服务端向浏览器返回的这个 HTML 就被称之为“表征”，你可能通过其他方式拿到本文的 PDF、Markdown、RSS 等其他形式的版本，它们也同样是一个资源的多种表征。</li>
<li><strong>状态</strong>（State）：当你读完了这篇文章，想看后面是什么内容时，你向服务器发出请求“给我下一篇文章”。但是“下一篇”是个相对概念，必须依赖“当前你正在阅读的文章是哪一篇”才能正确回应，这类在特定语境中才能产生的上下文信息即被称为“状态”。我们所说的有状态（Stateful）抑或是无状态（Stateless），都是只相对于服务端来说的，服务器要完成“取下一篇”的请求，要么自己记住用户的状态：这个用户现在阅读的是哪一篇文章，这称为有状态；要么客户端来记住状态，在请求的时候明确告诉服务器：我正在阅读某某文章，现在要读它的下一篇，这称为无状态。</li>
<li><strong>转移</strong>（Transfer）：无论状态是由服务端还是客户端来提供的，“取下一篇文章”这个行为逻辑必然只能由服务端来提供，因为只有服务端拥有该资源及其表征形式。服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”。</li>
<li><strong>统一接口</strong>（Uniform Interface）：上面说的服务器“通过某种方式”让表征状态发生转移，具体是什么方式？如果你真的是用浏览器阅读本文电子版的话，请把本文滚动到结尾处，右下角有下一篇文章的 URI 超链接地址，这是服务端渲染这篇文章时就预置好的，点击它让页面跳转到下一篇，就是所谓“某种方式”的其中一种方式。任何人都不会对点击超链接网页会出现跳转感到奇怪，但你细想一下，URI 的含义是统一资源标识符，是一个名词，如何能表达出“转移”动作的含义呢？答案是 HTTP 协议中已经提前约定好了一套“统一接口”，它包括：GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS 七种基本操作，任何一个支持 HTTP 协议的服务器都会遵守这套规定，对特定的 URI 采取这些操作，服务器就会触发相应的表征状态转移。</li>
<li><strong>超文本驱动</strong>（Hypertext Driven）：尽管表征状态转移是由浏览器主动向服务器发出请求所引发的，该请求导致了“在浏览器屏幕上显示出了下一篇文章的内容”这个结果的出现。但是，你我都清楚这不可能真的是浏览器的主动意图，浏览器是根据用户输入的 URI 地址来找到网站首页，服务器给予的首页超文本内容后，浏览器再通过超文本内部的链接来导航到了这篇文章，阅读结束时，也是通过超文本内部的链接来再导航到下一篇。浏览器作为所有网站的通用的客户端，任何网站的导航（状态转移）行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息（超文本）来驱动的。这点与其他带有客户端的软件有十分本质的区别，在那些软件中，业务逻辑往往是预置于程序代码之中的，有专门的页面控制器（无论在服务端还是在客户端中）来驱动页面的状态转移。</li>
<li><strong>自描述消息</strong>（Self-Descriptive Messages）：由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息。一种被广泛采用的自描述方法是在名为“Content-Type”的 HTTP Header 中标识出<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Media_type">互联网媒体类型</a>（MIME type），譬如“Content-Type : application/json; charset=utf-8”，则说明该资源会以 JSON 的格式来返回，请使用 UTF-8 字符集进行处理。</li>
</ul>
<p>RESTful 的系统</p>
<p>一套理想的、完全满足 REST 风格的系统应该满足以下六大原则</p>
<ul>
<li><strong>服务端与客户端分离</strong></li>
<li><strong>无状态</strong> （在服务端的内存、会话、数据库或者缓存等地方持有一定的状态成为一种是事实上存在，并将长期存在、被广泛使用的主流的方案。）</li>
<li><strong>可缓存</strong>REST 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来。运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。</li>
<li><strong>分层系统</strong>（Layered System）客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。该原则的典型的应用是内容分发网络（Content Distribution Network，CDN）。</li>
<li><strong>统一接口</strong> : 这是 REST 的另一条核心原则，REST 希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。</li>
<li><strong>按需代码</strong>指任何按照客户端（譬如浏览器）的请求，将可执行的软件程序从服务器发送到客户端的技术，按需代码赋予了客户端无需事先知道所有来自服务端的信息应该如何处理、如何运行的宽容度。</li>
</ul>
<p>REST 好处</p>
<ul>
<li>降低的服务接口的学习成本。</li>
<li>资源天然具有集合与层次结构。以资源为中心抽象的接口，由于资源是名词，天然就可以产生集合与层次结构。</li>
<li>REST 绑定于 HTTP 协议。</li>
</ul>
<p>RMM 成熟度</p>
<ol>
<li>The Swamp of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Plain_Old_XML">Plain Old XML</a>：完全不 REST。</li>
<li>Resources：开始引入资源的概念。</li>
<li>HTTP Verbs：引入统一接口，映射到 HTTP 协议的方法上。</li>
<li>Hypermedia Controls：超媒体控制在本文里面的说法是“超文本驱动”，在 Fielding 论文里的说法是“Hypertext As The Engine Of Application State，HATEOAS”，其实都是指同一件事情。</li>
</ol>
<p>不足与争议</p>
<p><strong>面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑</strong></p>
<p><strong>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中</strong></p>
<p><strong>REST 不利于事务支持</strong></p>
<p><strong>REST 没有传输可靠性支持</strong></p>
<p><strong>REST 缺乏对资源进行“部分”和“批量”的处理能力</strong></p>
<h2 id="事务处理"><a class="markdownIt-Anchor" href="#事务处理"></a> 事务处理</h2>
<h4 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h4>
<ul>
<li><strong>原子性</strong>（<strong>A</strong>tomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。</li>
<li><strong>隔离性</strong>（<strong>I</strong>solation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。</li>
<li><strong>持久性</strong>（<strong>D</strong>urability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。</li>
</ul>
<p>目的</p>
<p>​	保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的<strong>一致性</strong>（<strong>C</strong>onsistency）。</p>
<h3 id="本地事务"><a class="markdownIt-Anchor" href="#本地事务"></a> 本地事务</h3>
<p>仅仅适用于<strong>单个服务使用单个数据源</strong></p>
<p>实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的，不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。正因为写入中间状态与崩溃都不可能消除，所以如果不做额外保障措施的话，将内存中的数据写入磁盘，并不能保证原子性与持久性。</p>
<h4 id="原子性持久性"><a class="markdownIt-Anchor" href="#原子性持久性"></a> 原子性持久性</h4>
<p>实现原子性于持久性的两个方案</p>
<ul>
<li>提交日志 （Commit Logging ） 将修改数据这个操作所需的全部信息（修改后数据，数据物理块位置，什么改成什么等）日志落盘后才会开始修改数据</li>
<li>影子分页 （Commit Logging ）将拷贝的数据复制一份副本，然后对副本进行操作最后将数据的引用指针<strong>指向</strong>（原子性）修改后的数据</li>
</ul>
<p>按照事务提交时点为界划分</p>
<ul>
<li><strong>FORCE</strong>：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE</li>
<li><strong>STEAL</strong>：在事务提交前，允许变动数据提前写入则称为 STEAL</li>
</ul>
<p>Write-Ahead Logging （NO-FORCE STEAL）</p>
<p>添加回滚日志UndoLog ，记录已经修改的数据，可以一边写写事务日志一般修改数据解决日志写入后才能一次性修改数据 占用大量内存</p>
<p>崩溃恢复</p>
<ul>
<li><strong>分析阶段</strong>（Analysis）：找出待恢复的事务集合 （已经commit完的与未commit的）</li>
<li><strong>重做阶段</strong>（Redo）：根据待恢复的事务（已经commit完的）集合来重演历史（幂等）</li>
<li><strong>回滚阶段</strong>（Undo）：根据 Undo Log 中的信息，回滚未commit完的数据（幂等）</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211213231725473.png" alt="image-20211213231725473" /></p>
<h4 id="隔离性"><a class="markdownIt-Anchor" href="#隔离性"></a> 隔离性</h4>
<p>实现方案 加锁</p>
<ul>
<li><strong>写锁</strong>（Write Lock）</li>
<li><strong>读锁</strong>（Read Lock）</li>
<li><strong>范围锁</strong>（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。如下语句是典型的加范围锁的例子：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrency_control">并发控制理论</a>（Concurrency Control）决定了隔离程度与并发能力是相互抵触的，<strong>隔离程度越高，并发访问时的吞吐量就越低</strong>。</p>
<p>隔离级别</p>
<ul>
<li>
<p>可串行化： 强度最高的隔离性</p>
</li>
<li>
<p>可重复读： 读写锁，无范围锁    会产生<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Phantom_reads">幻读问题</a> 在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(name,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>)	<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读已提交：读锁在查询操作完成后就马上会释放。 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads">不可重复读问题</a> 在事务执行过程中，对同一行数据的两次查询得到了不同的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">110</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;			<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;   </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读未提交 完全不加读锁。 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads">脏读问题</a> 在事务执行过程中，一个事务读取到了另一个事务未提交的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/* 注意没有COMMIT */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">90</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;					<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/* 这条SELECT模拟购书的操作的逻辑 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;			  				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;			  										<span class="comment">/* 时间顺序：4，事务： T2 */</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>完全不隔离  脏写问题 即一个事务的没提交之前的修改可以被另外一个事务的修改覆盖掉，(没有原子性 所以不讨论)</p>
</li>
</ul>
<p>无锁优化方案</p>
<p>“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">多版本并发控制</a>”（Multi-Version Concurrency Control，MVCC）</p>
<p>MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。（CREATE_VERSION 和 DELETE_VERSION，这两个字段记录的值都是事务 ID）</p>
<ul>
<li>插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。</li>
<li>删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。</li>
<li>修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。</li>
</ul>
<p>将根据隔离级别来决定到底应该读取哪个版本的数据。</p>
<ul>
<li>隔离级别是<code>可重复读</code>：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。</li>
<li>隔离级别是<code>读已提交</code>：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。</li>
</ul>
<p>MVCC 是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况</p>
<h3 id="全局事务"><a class="markdownIt-Anchor" href="#全局事务"></a> 全局事务</h3>
<p>一种适用于单个服务使用多个数据源场景</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">两段式提交</a>”（2 Phase Commit，2PC）协议</p>
<ul>
<li><strong>准备阶段</strong>：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。</li>
<li><strong>提交阶段</strong>：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。</li>
</ul>
<p>上面所说的协调者、参与者都是可以由数据库自己来扮演的，</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211214231409011.png" alt="image-20211214231409011" /></p>
<p>XA的前提：</p>
<ul>
<li>必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。同时也假设网络通信在全过程都不会出现误差，即可以丢失消息，但不会传递错误的消息.XA 的设计目标并不是解决诸如<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byzantine_fault">拜占庭将军</a>一类的问题。</li>
<li>必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。</li>
</ul>
<blockquote>
<p>拜占庭将军:In a Byzantine fault, a component such as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Server_(computing)">server</a> can inconsistently appear both failed and functioning to failure-detection systems, presenting different symptoms to different observers. It is difficult for the other components to declare it failed and shut it out of the network, because they need to first reach a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">consensus</a> regarding which component has failed in the first place.</p>
</blockquote>
<p>缺点</p>
<ul>
<li><strong>单点问题</strong> 协调者宕机，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。</li>
<li><strong>性能问题</strong>：两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），性能由参与者集群中最慢决定,故而性能比较差。</li>
<li><strong>一致性风险</strong>：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。</li>
</ul>
<blockquote>
<p>“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consensus_(computer_science)#Solvability_results_for_some_agreement_problems">FLP 不可能原理</a>”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">三段式提交</a>”（3 Phase Commit，3PC）协议</p>
<p>三段式提交把原本的两段式提交的准备阶段再细分为两个阶段，分别称为</p>
<ul>
<li>CanCommit（协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。）、</li>
<li>PreCommit，原准备阶段</li>
<li>DoCommit ，提交阶段 ，如果在 PreCommit 阶段之后发生了协调者宕机，即参与者没有能等到 DoCommit 的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211215220806915.png" alt="image-20211215220806915" /></p>
<p>三段式提交对<strong>单点问题</strong>和回滚时的<strong>性能问题</strong>有所改善，但是它对<strong>一致性风险问题</strong>风险甚至反而是略有增加了的。回滚时超时反而提交了。</p>
<h3 id="共享事务"><a class="markdownIt-Anchor" href="#共享事务"></a> 共享事务</h3>
<p>多个服务共用同一个数据源。</p>
<p>实现共享事务，就必须新增一个“交易服务器”的中间角色，无论是用户服务、商家服务还是仓库服务，它们都通过同一台交易服务器来与数据库打交道。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211215221913321.png" alt="image-20211215221913321" /></p>
<p>该方案是与实际生产系统中的压力方向相悖的，一个服务集群里数据库才是压力最大而又最不容易伸缩拓展的重灾区，所以现实中只有类似<a target="_blank" rel="noopener" href="https://www.proxysql.com/">ProxySQL</a>、<a target="_blank" rel="noopener" href="https://mariadb.com/kb/en/maxscale/">MaxScale</a>这样用于对多个数据库实例做负载均衡的数据库代理（其实用 ProxySQL 代理单个数据库，再启用 Connection Multiplexing，已经接近于前面所提及的交易服务器方案了）</p>
<p>使用消息队列服务器来代替交易服务器。用户、商家、仓库的服务操作业务时，通过消息将所有对数据库的改动传送到消息队列服务器，通过消息的消费者来统一处理，实现由本地事务保障的持久化操作。这被称作“<a target="_blank" rel="noopener" href="https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html">单个数据库的消息驱动更新</a></p>
<h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3>
<p>多个服务同时访问多个数据源的事务处理机制</p>
<h4 id="cap"><a class="markdownIt-Anchor" href="#cap"></a> CAP</h4>
<p>彻底地击碎了XA 的事务机制可以在本节所说的分布式环境中也能良好地应用的美好的愿望</p>
<p>三个特性最多只能同时满足其中两个，<strong>由于一般不放弃分区容错性，故而只有AP(主流)跟CP</strong></p>
<ul>
<li><strong>一致性</strong>（<strong>C</strong>onsistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。一致性在分布式研究中是有严肃定义、有多种细分类型的概念，以后讨论分布式共识算法时，我们还会再提到一致性，那种面向副本复制的一致性与这里面向数据库状态的一致性严格来说并不完全等同，具体差别我们将在后续分布式共识算法中再作探讨。</li>
<li><strong>可用性</strong>（<strong>A</strong>vailability）：代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A=MTBF/（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999%可用，即代表平均年故障修复时间为 32 秒。</li>
<li><strong>分区容忍性</strong>（<strong>P</strong>artition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。</li>
</ul>
<p>本章讨论的话题“事务”原本的目的就是获得“一致性”，而在分布式环境中，“一致性”却不得不成为通常被牺牲、被放弃的那一项属性。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Eventual_consistency">最终一致性</a>”（Eventual Consistency），它是指：如果数据在一段时间之内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法也被称为“乐观复制算法”。</p>
<h4 id="base"><a class="markdownIt-Anchor" href="#base"></a> BASE</h4>
<ul>
<li>基本可用性（<strong>B</strong>asically <strong>A</strong>vailable）</li>
<li>-柔性事务（<strong>S</strong>oft State）</li>
<li>最终一致性（<strong>E</strong>ventually Consistent）</li>
</ul>
<h4 id="柔性事务实现方式"><a class="markdownIt-Anchor" href="#柔性事务实现方式"></a> 柔性事务实现方式</h4>
<h5 id="可靠事件队列"><a class="markdownIt-Anchor" href="#可靠事件队列"></a> 可靠事件队列</h5>
<p>靠着持续重试来保证可靠性的解决方案。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211215232245727.png" alt="image-20211215232245727" /></p>
<p>顺序</p>
<ul>
<li>事务排序：顺序就应该安排成最容易出错的最先进行。顺序就应该安排成最容易出错的最先进行</li>
<li>执行第一个事务：账号服务进行扣款业务，如扣款成功，则在自己的数据库建立一张消息表，里面存入一条消息。</li>
<li>信息服务轮询 ：根据消息表 轮询 重发 执行未成功事务 直到全部成功。在系统中建立一个消息服务，定时轮询消息表，将状态是“进行中”的消息同时发送到库存和商家服务节点中去。</li>
</ul>
<p>信息服务轮询的可重复性决定了所有被消息服务器发送的消息都必须具备幂等性，通常的设计是让消息带上一个唯一的事务 ID。</p>
<p>可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败。</p>
<p>消息服务可以由支持分布式事务的消息框架替代。</p>
<p>缺点</p>
<p><strong>整个过程完全没有任何隔离性可言</strong></p>
<h5 id="tcc-事务"><a class="markdownIt-Anchor" href="#tcc-事务"></a> TCC 事务</h5>
<p>Try-Confirm-Cancel”</p>
<p>步骤</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211215232220122.png" alt="image-20211215232220122" /></p>
<p>实际步骤</p>
<ol>
<li>生成事务ID，记录到日志中</li>
<li>Try  遍历每一个服务 检查业务可行性，可行的话冻结资源 进入Confirm  否则 进入Cancel</li>
<li>Confirm  遍历每一个服务 完成业务操作 失败时重复Confirm 操作即进行最大努力交付。</li>
<li>Cancel 取消所有业务操作 释放冻结支援</li>
</ol>
<p>好处</p>
<ul>
<li>于用户代码层面，较高的灵活性，可以根据需要设计资源锁定的粒度。</li>
<li>业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。</li>
</ul>
<p>坏处</p>
<ul>
<li>更高的开发成本和更换事务实现方案的替换成本</li>
<li>业务侵入性</li>
</ul>
<p>基于某些分布式事务中间件（譬如阿里开源的<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/">Seata</a>）去完成</p>
<h5 id="saga-事务"><a class="markdownIt-Anchor" href="#saga-事务"></a> SAGA 事务</h5>
<p>将一个分布式环境中的大事务分解为一系列本地事务的设计模式。（通过数据补偿进行）</p>
<ul>
<li>大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。</li>
<li>为每一个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti与 Ci必须满足以下条件：
<ul>
<li>Ti与 Ci都具备幂等性。</li>
<li>Ti与 Ci满足交换律（Commutative），即先执行 Ti还是先执行 Ci，其效果都是一样的。</li>
<li>Ci必须能成功提交，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</li>
</ul>
</li>
</ul>
<p>如果 T1到 Tn均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一：</p>
<ul>
<li><strong>正向恢复</strong>（Forward Recovery）：如果 Ti事务提交失败，则一直对 Ti进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。</li>
<li><strong>反向恢复</strong>（Backward Recovery）：如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止（最大努力交付）。这里要求 Ci必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</li>
</ul>
<p>SAGA 必须保证所有子事务都得以提交或者补偿，但 SAGA 系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为 SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况，譬如执行至哪一步或者补偿至哪一步了。</p>
<p>SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。</p>
<h5 id="at-事务模式"><a class="markdownIt-Anchor" href="#at-事务模式"></a> <a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">AT 事务模式</a></h5>
<p>AT 事务是参照了 XA 两段提交协议实现的但在业务数据提交时自动拦截所有 SQL，将 SQL 对数据修改前、修改后的结果分别保存快照，生成行锁，通过本地事务一起提交到操作的数据源中，相当于自动记录了重做和回滚日志。如果分布式事务成功提交，那后续清理每个数据源中对应的日志数据即可；</p>
<p>大幅度地牺牲了隔离性，甚至直接影响到了原子性。会出现脏写。</p>
<p>脏写解决方式：</p>
<p>GTS 增加了一个“全局锁”（Global Lock）的机制来实现写隔离，要求本地事务提交之前，一定要先拿到针对修改记录的全局锁后才允许提交，没有获得全局锁之前就必须一直等待，这种设计以牺牲一定性能为代价，避免了有两个分布式事务中包含的本地事务修改了同一个数据，从而避免脏写。</p>
<p><strong>分布式事务中没有一揽子包治百病的解决办法，因地制宜地选用合适的事务处理方案才是唯一有效的做法。</strong></p>
<h2 id="透明多级分流系统"><a class="markdownIt-Anchor" href="#透明多级分流系统"></a> 透明多级分流系统</h2>
<p>不同的设施、部件在系统中有各自不同的价值。</p>
<p>系统进行流量规划设计原则</p>
<ul>
<li>第一条原则是尽可能减少单点部件</li>
<li>奥卡姆剃刀原则。不是每一个系统都要追求高并发、高可用的，根据系统的<strong>用户量</strong>、<strong>峰值流量</strong>和<strong>团队本身的技术与运维能力</strong>来考虑如何部署这些设施才是合理的做法，在能满足需求的前提下，<strong>最简单的系统就是最好的系统</strong>。</li>
</ul>
<h3 id="客户端缓存"><a class="markdownIt-Anchor" href="#客户端缓存"></a> 客户端缓存</h3>
<blockquote>
<p>客户端缓存（Client Cache）</p>
<p>HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷。</p>
</blockquote>
<h4 id="强制缓存"><a class="markdownIt-Anchor" href="#强制缓存"></a> 强制缓存</h4>
<p>假设在某个时点到来以前，资源的内容和状态一定不会被改变，因此客户端可以无须经过任何请求，在该时点前一直持有和使用该资源的本地缓存副本。</p>
<p><strong>在用户主动刷新页面时应当自动失效</strong></p>
<p>以下两类 Header 实现强制缓存</p>
<ul>
<li>
<p><strong>Expires</strong>：Expires 是 HTTP/1.0 协议中开始提供的 Header，后面跟随一个截至时间参数。</p>
<ul>
<li>受限于客户端的本地时间。</li>
<li>无法处理涉及到用户身份的私有资源（私有资源如果缓冲到代理服务器或CDN则有泄露的风险）</li>
<li>无法描述“<strong>不</strong>缓存”的语义</li>
</ul>
</li>
<li>
<p><strong>Cache-Control</strong>：Cache-Control 是 HTTP/1.1 协议中定义的强制缓存 Header，它的语义比起 Expires 来说就丰富了很多</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=600</span><br></pre></td></tr></table></figure>
<p>标准参数</p>
<ul>
<li>
<p><strong>max-age</strong>和<strong>s-maxage</strong>：max-age 后面跟随一个以秒为单位的数字，表明相对于请求时间（在 Date Header 中会注明请求时间）多少秒以内缓存是有效的</p>
</li>
<li>
<p><strong>public</strong>和<strong>private</strong>：指明是否涉及到用户身份的私有资源，如果是 public，则可以被代理、CDN 等缓存，如果是 private，则只能由用户的客户端进行私有缓存。</p>
</li>
<li>
<p><strong>no-cache</strong>和<strong>no-store</strong>：no-cache 指明该资源不应该被缓存，必须从服务端获取，令强制缓存完全失效，但此时协商缓存机制依然是生效的；no-store 不强制会话中相同 URL 资源的重复获取，但禁止浏览器、CDN 等以任何形式保存该资源。</p>
</li>
<li>
<p><strong>no-transform</strong>：禁止资源被任何形式地修改。譬如，某些 CDN、透明代理支持自动 GZip 压缩图片或文本，以提升网络性能</p>
</li>
<li>
<p><strong>min-fresh</strong>和<strong>only-if-cached</strong>：这两个参数是仅用于客户端的请求 Header。min-fresh 后续跟随一个以秒为单位的数字，用于建议服务器能返回一个不少于该时间的缓存资源（即包含 max-age 且不少于 min-fresh 的数字）。only-if-cached 表示客户端要求不必给它发送资源的具体内容，此时客户端就仅能使用事先缓存的资源来进行响应，若缓存不能命中，就直接返回 503/Service Unavailable 错误。</p>
</li>
<li>
<p><strong>must-revalidate</strong>和<strong>proxy-revalidate</strong>：must-revalidate 表示在资源过期后，一定需要从服务器中进行获取，即超过了 max-age 的时间后，就等同于 no-cache 的行为，proxy-revalidate 用于提示代理、CDN 等设备资源过期后的缓存行为，除对象不同外，语义与 must-revalidate 完全一致。</p>
</li>
</ul>
</li>
</ul>
<h4 id="协商缓存"><a class="markdownIt-Anchor" href="#协商缓存"></a> 协商缓存</h4>
<p>基于检测的缓存机制，通常被称为“协商缓存”</p>
<p>在 HTTP 中协商缓存与强制缓存并没有互斥性，这两套机制是并行工作的</p>
<p>协商缓存有两种变动检查机制，分别是根据资源的修改时间进行检查，以及根据资源唯一标识是否发生变化来进行检查，</p>
<ul>
<li>
<p><strong>Last-Modified 和 If-Modified-Since</strong>：Last-Modified 是服务器的响应 Header，用于告诉客户端这个资源的最后修改时间。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-Modified-Since 把之前收到的资源最后修改时间发送回服务端。</p>
<p>如果此时服务端发现资源在该时间后没有被修改过，就只要返回一个 304/Not Modified 的响应即可，无须附带消息体，达到节省流量的目的，如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 8 Apr 2020 15:31:30 GMT</span><br></pre></td></tr></table></figure>
<p>如果此时服务端发现资源在该时间之后有变动，就会返回 200/OK 的完整响应，在消息体中包含最新的资源，如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 8 Apr 2020 15:31:30 GMT</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="attribute">Content</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Etag 和 If-None-Match</strong>：Etag 是服务器的响应 Header，用于告诉客户端这个资源的唯一标识。HTTP 服务器可以根据自己的意愿来选择如何生成这个标识，譬如 Apache 服务器的 Etag 值默认是对文件的索引节点（INode），大小和最后修改时间进行哈希计算后得到的。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-None-Match 把之前收到的资源唯一标识发送回服务端。</p>
<p>如果此时服务端计算后发现资源的唯一标识与上传回来的一致，说明资源没有被修改过，就只要返回一个 304/Not Modified 的响应即可，无须附带消息体，达到节省流量的目的，如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;28c3f612-ceb0-4ddc-ae35-791ca840c5fa&quot;</span><br></pre></td></tr></table></figure>
<p>如果此时服务端发现资源的唯一标识有变动，就会返回 200/OK 的完整响应，在消息体中包含最新的资源，如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;28c3f612-ceb0-4ddc-ae35-791ca840c5fa&quot;</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="attribute">Content</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Last-Modified 标注的最后修改只能精确到<strong>秒级</strong>，不能准确标注文件一秒内的修改时间；也可能内容没变，Last-Modified变了。</p>
<p>Etag 是 HTTP 中<strong>一致性最强</strong>的缓存机制，但是每次服务端都必须对资源进行哈希计算，故而是<strong>性能最差</strong>的缓存机制。</p>
<p>Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内。</p>
<h4 id="单个资源识别"><a class="markdownIt-Anchor" href="#单个资源识别"></a> 单个资源识别</h4>
<p>HTTP 协议设计了以 Accept*（Accept、Accept-Language、Accept-Charset、Accept-Encoding）开头的一套请求 Header 和对应的以 Content-*（Content-Language、Content-Type、Content-Encoding）开头的响应 Header，这些 Headers 被称为 HTTP 的内容协商机制。</p>
<h4 id="多个资源标识"><a class="markdownIt-Anchor" href="#多个资源标识"></a> 多个资源标识</h4>
<p>Vary Header 对于一个 URL 能够获取多个资源的场景中，缓存也同样也需要有明确的标识来获知根据什么内容来对同一个 URL 返回给用户正确的资源</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept, User-Agent</span><br></pre></td></tr></table></figure>
<p>根据 MIME 类型和浏览器类型来缓存资源，获取资源时也需要根据请求 Header 中对应的字段来筛选出适合的资源版本。</p>
<p>刷新页面（F5）时也同样是生效的，只有用户强制刷新（Ctrl+F5）或者明确禁用缓存（譬如在 DevTools 中设定）时才会失效，</p>
<h3 id="域名缓存dns"><a class="markdownIt-Anchor" href="#域名缓存dns"></a> 域名缓存（DNS ）</h3>
<blockquote>
<p>DNS 也许是全世界最大、使用最频繁的信息查询系统，如果没有适当的分流机制，DNS 将会成为整个网络的瓶颈。</p>
</blockquote>
<p><strong>震惊！世界根域名服务器的 ZONE 文件竟然只有 2MB 大小</strong></p>
<p>DNS解析步骤</p>
<p>例如 <a target="_blank" rel="noopener" href="http://www.icyfenix.com.cn">www.icyfenix.com.cn</a></p>
<ul>
<li>域名还原 ： <strong><a target="_blank" rel="noopener" href="http://www.icyfenix.com.cn">www.icyfenix.com.cn</a>.</strong></li>
<li>客户端先检查本地的 DNS 缓存：根据<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Time_to_live">存活时间</a>（Time to Live，TTL）来衡量缓存的有效情况。</li>
<li>客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）</li>
<li>本地 DNS 收到查询请求后判断 有无对于的<strong>权威域名服务器</strong>
<ul>
<li>是否有<code>www.icyfenix.com.cn</code>的权威服务器</li>
<li>是否有<code>icyfenix.com.cn</code>的权威服务器</li>
<li>是否有<code>com.cn</code>的权威服务器</li>
<li>是否有<code>cn</code>的权威服务器</li>
<li>. 的根域名服务器</li>
</ul>
</li>
<li>假如到根域名服务器后
<ul>
<li>通过根域名服务器 得到 <code>cn</code>的权威服务器 的地址记录</li>
<li>通过“<code>cn</code>的权威服务器”，得到“<code>com.cn</code>的权威服务器”的地址记录</li>
<li>以此类推，最后找到能够解释<code>www.icyfenix.com.cn</code>的权威服务器地址</li>
</ul>
</li>
<li>通过“<code>www.icyfenix.com.cn</code>的权威服务器”，查询<code>www.icyfenix.com.cn</code>的地址记录，（譬如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、主机别名 CNAME 记录，等等。）</li>
</ul>
<p>每种记录类型中还可以包括多条记录，以一个域名下配置多条不同的 A 记录为例，此时权威服务器可以根据自己的策略来进行选择，典型的应用是智能线路：根据访问者所处的不同地区、不同服务商等因素来确定返回最合适的 A 记录，将访问者路由到最合适的数据中心，达到智能加速的目的。</p>
<p>缺点优化</p>
<ul>
<li>极端情况下响应速度慢：“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Link_prefetching">DNS 预取</a>”在网页加载时生成一个 link 请求，促使浏览器提前对该域名进行预解释，譬如下面代码所示：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//domain.not-icyfenx.cn&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>受到中间人攻击的威胁：位于递归链底层或者来自本地运营商的 Local DNS 服务器的安全防护则相对松懈。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DNS_over_HTTPS">HTTPDNS</a>（也称为 DNS over HTTPS，DoH）。它将原本的 DNS 解析服务开放为一个基于 HTTPS 协议的查询服务，替代基于 UDP 传输协议的 DNS 域名解析，通过程序代替操作系统直接从权威 DNS 或者可靠的 Local DNS 获取解析数据，从而绕过传统 Local DNS。</p>
</li>
</ul>
<h3 id="传输链路"><a class="markdownIt-Anchor" href="#传输链路"></a> 传输链路</h3>
<p>优化链路传输为目的的前端设计原则，譬如经典的<a target="_blank" rel="noopener" href="https://developer.yahoo.com/performance/rules.html">雅虎 YSlow-23 条规则</a></p>
<p>缺陷：</p>
<p>HTTP 传输对象的主要特征是<strong>数量多、时间短、资源小、切换快</strong>。把小文件合并成大文件，在 HTTP/2 下是毫无好处的。</p>
<p>TCP 协议要求必须在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment">三次握手</a>而且还有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start">慢启动</a>的特性，因此并不适合HTTP。为此优化为</p>
<ul>
<li>
<p>连接数优化 副作用：资源耦合 缓存效率下降</p>
</li>
<li>
<p>连接复用技术（连接<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Keepalive">Keep-Alive 机制</a>） 副作用是“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Head-of-line_blocking">队首阻塞</a></p>
</li>
<li>
<p>HTTP/2 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7540#page-15">多路复用</a> (最小单位由请求变成了 <strong>帧</strong> ，可同时多个连接数据混在一起 接收时数据重组，因此无需压缩请求数)</p>
</li>
<li>
<p>数据压缩</p>
</li>
<li>
<p>快速 UDP 网络连接（QUIC）以 UDP 协议为基础，提供可靠传输能力。</p>
<p>​	优点如下</p>
<ul>
<li>能对每个流能做单独的控制 (一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务)</li>
<li>使用<strong>连接标识符</strong>唯一地标识客户端与服务器之间的连接，切换IP（数据切换wifi），原始连接连接标识符依然是有效的。</li>
<li>QUIC 连接失败时以零延迟回退到 TCP 连接</li>
</ul>
</li>
</ul>
<h3 id="内容分发网络"><a class="markdownIt-Anchor" href="#内容分发网络"></a> 内容分发网络</h3>
<blockquote>
<p>CDN 是一种十分古老而又十分透明，没什么存在感的分流系统，许多人都说听过它，但真正了解过它的人却很少。</p>
</blockquote>
<p>互联网系统的速度取决于以下四点因素：</p>
<ul>
<li>网站服务器出口带宽</li>
<li>用户客户端入口带宽。</li>
<li>从网站到用户之间经过的不同运营商之间互联节点的带宽</li>
<li>网站到用户之间的物理链路传输时延（Ping）</li>
</ul>
<p>内容分发网络的工作过程</p>
<ul>
<li>
<p><strong>路由解析</strong></p>
<ol>
<li>
<p>将服务器的 IP 地址在你的 CDN 服务商上注册为“源站”，注册后你会得到一个 CNAME</p>
</li>
<li>
<p>将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。</p>
</li>
<li>
<p>当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。</p>
</li>
<li>
<p>本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS。DNS 服务将根据一定的均衡策略和参数，DNS 服务将根据一定的均衡策略和参数。</p>
</li>
<li>
<p>浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211222223531779.png" alt="image-20211222223531779" /></p>
</li>
</ol>
</li>
<li>
<p><strong>内容分发</strong>（CDN 获取源站资源的过程）</p>
<ul>
<li><strong>主动分发</strong>（Push）：分发由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。通常需要源站、CDN 服务双方提供程序 API 接口层面的配合。一般用于网站要预载大量资源的场景。如：双十一抢购</li>
<li><strong>被动回源</strong>（Pull）：被动回源由用户访问所触发全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点发现自己没有该资源，就会实时从源站中获取。首次访问通常是比较慢的，不适合应用于数据量较大的资源。完全的双向透明，</li>
</ul>
</li>
<li>
<p><strong>CDN 应用</strong></p>
<ol>
<li>
<p>加速静态资源</p>
</li>
<li>
<p>安全防御：CDN 在广义上可以视作网站的堡垒机</p>
</li>
<li>
<p>协议升级：不少 CDN 提供商都同时对接（代售 CA 的）SSL 证书服务，可以实现源站是 HTTP 协议的，而对外开放的网站是基于 HTTPS 的。</p>
</li>
<li>
<p>状态缓存：不仅可以缓存源站的资源，还可以缓存源站的状态，</p>
<p>譬如源站的</p>
<ul>
<li>301/302 转向，</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2">OCSP 装订</a>加速 SSL 证书访问，</li>
<li>CDN 开启<a target="_blank" rel="noopener" href="https://es.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a></li>
<li>404</li>
</ul>
</li>
<li>
<p>修改资源：CDN 可以在返回资源给用户的时候修改它的任何内容，以实现不同的目的。如</p>
<ul>
<li>未压缩的资源自动压缩并修改 Content-Encoding</li>
<li>未启用客户端缓存的内容加上缓存 Header</li>
<li>修改<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">CORS</a>的相关 Header，将源站不支持跨域的资源提供跨域能力</li>
<li>…</li>
</ul>
</li>
<li>
<p>访问控制：</p>
<ul>
<li>
<p>CDN 可以实现 IP 黑/白名单功能</p>
</li>
<li>
<p>不同的来访 IP 提供不同的响应结果</p>
</li>
<li>
<p>根据 IP 的访问流量来实现 QoS 控制</p>
</li>
<li>
<p>根据 HTTP 的 Referer 来实现防盗链</p>
</li>
</ul>
</li>
<li>
<p>注入功能：在不修改源站代码的前提下，为源站注入各种功能</p>
</li>
</ol>
</li>
</ul>
<h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3>
<blockquote>
<p>调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为“负载均衡”。</p>
</blockquote>
<p>负载均衡，从形式上来说都可以分为两种：四层负载均衡和七层负载均衡。（经典的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OSI_model">OSI 七层模型</a>中第四层传输层和第七层应用层。）</p>
<p>最典型的 1500 Bytes MTU 的以太网帧结构说明</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>层</strong></th>
<th><strong>数据单元</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>应用层 Application Layer</td>
<td>数据 Data</td>
<td>提供为应用软件提供服务的接口，用于与其他应用软件之间的通信。典型协议：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 等</td>
</tr>
<tr>
<td>6</td>
<td>表达层 Presentation Layer</td>
<td>数据 Data</td>
<td>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</td>
</tr>
<tr>
<td>5</td>
<td>会话层 Session Layer</td>
<td>数据 Data</td>
<td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</td>
</tr>
<tr>
<td>4</td>
<td>传输层 Transport Layer</td>
<td>数据段 Segments</td>
<td>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。典型协议：TCP、UDP、RDP、SCTP、FCP 等</td>
</tr>
<tr>
<td>3</td>
<td>网络层 Network Layer</td>
<td>数据包 Packets</td>
<td>决定数据的传输路径选择和转发，将网络表头附加至数据段后以形成报文（即数据包）。典型协议：IPv4/IPv6、IGMP、ICMP、EGP、RIP 等</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层 Data Link Layer</td>
<td>数据帧 Frame</td>
<td>负责点对点的网络寻址、错误侦测和纠错。当表头和表尾被附加至数据包后，就形成数据帧（Frame）。典型协议：WiFi（802.11）、Ethernet（802.3）、PPP 等。</td>
</tr>
<tr>
<td>1</td>
<td>物理层 Physical Layer</td>
<td>比特流 Bit</td>
<td>在物理网络上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</td>
</tr>
</tbody>
</table>
<p>现在所说的“四层负载均衡”其实是多种均衡器工作模式的统称，“四层”的意思是说这些工作模式的共同特点是维持着同一个 TCP 连接，而不是说它只工作在第四层。</p>
<h4 id="数据链路层负载均衡"><a class="markdownIt-Anchor" href="#数据链路层负载均衡"></a> 数据链路层负载均衡</h4>
<blockquote>
<p>每一块网卡都有独立的 MAC 地址，以太帧上这两个地址告诉了交换机，此帧应该是从连接在交换机上的哪个端口的网卡发出，送至哪块网卡的。</p>
</blockquote>
<p>数据链路层负载均衡(三角传输模式 单臂模式 直接路由 )所做的工作，是<strong>修改请求的数据帧中的 MAC 目标地址</strong>，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（后文称为“真实服务器”，Real Server）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。<strong>需要把真实物理服务器集群所有机器的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_IP_address">虚拟 IP 地址</a>（Virtual IP Address，VIP）配置成与负载均衡器的虚拟 IP 一样</strong>。响应结果就不再需要通过负载均衡服务器进行地址交换，可将响应结果的数据包直接从真实服务器返回给用户的客户端。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211222231334218.png" alt="image-20211222231334218" /></p>
<h4 id="网络层负载均衡"><a class="markdownIt-Anchor" href="#网络层负载均衡"></a> 网络层负载均衡</h4>
<p>分组数据包的 Headers 部分说明</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>存储信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-4 Bytes</td>
<td>版本号（4 Bits）、首部长度（4 Bits）、分区类型（8 Bits)、总长度（16 Bits）</td>
</tr>
<tr>
<td>5-8 Bytes</td>
<td>报文计数标识（16 Bits）、标志位（4 Bits）、片偏移（12 Bits）</td>
</tr>
<tr>
<td>9-12 Bytes</td>
<td>TTL 生存时间（8 Bits）、上层协议代号（8 Bits）、首部校验和（16 Bits）</td>
</tr>
<tr>
<td>13-16 Bytes</td>
<td>源地址（32 Bits）</td>
</tr>
<tr>
<td>17-20 Bytes</td>
<td>目标地址（32 Bits）</td>
</tr>
<tr>
<td>20-60 Bytes</td>
<td>可选字段和空白填充</td>
</tr>
</tbody>
</table>
<p>网络层负载均衡通过改变这里面的 IP 地址来实现数据包的转发。</p>
<p>两种常见的修改方式</p>
<ul>
<li>
<p>保持原来的数据包不变，新创建一个数据包,这个新数据包的 Headers 中<strong>写入真实服务器的 IP 作为目标地址</strong>,原来数据包的 Headers 和 Payload 整体作为另一个新的数据包的 Payload(封包 影响效率)。真实服务器收到数据包后，必须在接收入口处设计一个针对性的拆包机制.(套娃)</p>
<p>缺点: 服务器支持拆包与<strong>虚拟IP</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211226162443263.png" alt="image-20211226162443263" /></p>
</li>
<li>
<p>NAT 模式的负载均衡器（较大性能损失）<img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211226162751661.png" alt="image-20211226162751661" /></p>
</li>
</ul>
<h4 id="应用层负载均衡"><a class="markdownIt-Anchor" href="#应用层负载均衡"></a> 应用层负载均衡</h4>
<p>根据“哪一方能感知到”的原则，可以分为“<strong>正向代理</strong>”、“反向代理”和“<strong>透明代理</strong>”三类。</p>
<p>与四层均衡器对比的缺点：</p>
<ul>
<li>比四层均衡器至少多一轮 TCP 握手，有着跟 NAT 转发模式一样的带宽问题</li>
<li>通常要耗费更多的 CPU，因为可用的解析规则远比四层丰富。</li>
</ul>
<p>优点以及功能</p>
<ul>
<li>感知应用层通信的具体内容，往往能够做出更明智的决策，花样多。</li>
<li>缓存</li>
<li>可以实现更智能化的路由。</li>
<li>某些安全攻击可以由七层均衡器来抵御</li>
<li>链路治理措施</li>
</ul>
<h4 id="均衡策略与实现"><a class="markdownIt-Anchor" href="#均衡策略与实现"></a> 均衡策略与实现</h4>
<p>常见均衡策略</p>
<ul>
<li><strong>轮循均衡</strong></li>
<li><strong>权重轮循均衡</strong></li>
<li><strong>随机均衡</strong></li>
<li><strong>权重随机均衡</strong></li>
<li><strong>一致性哈希均衡</strong> ：根据请求中某一些数据（可以是 MAC、IP 地址，也可以是更上层协议中的某些参数信息）作为特征值来计算需要落在的节点上</li>
<li><strong>响应速度均衡</strong>（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的(<strong>负载均衡设备与服务器间的</strong>)最快响应时间来决定哪一台服务器来响应客户端的服务请求。</li>
<li><strong>最少连接数均衡</strong> 适合长时处理的请求服务，如 FTP 传输。</li>
</ul>
<p>实现：</p>
<p>软件均衡器：</p>
<ul>
<li>
<p>操作系统内核(性能比较好)：LVS</p>
</li>
<li>
<p>应用程序形式：Nginx、HAProxy、KeepAlived</p>
</li>
</ul>
<p>硬件均衡器：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">应用专用集成电路 ASIC  </a> ：有专用处理芯片的支持，避免操作系统层面的损耗</li>
</ul>
<h3 id="服务端缓存"><a class="markdownIt-Anchor" href="#服务端缓存"></a> 服务端缓存</h3>
<blockquote>
<p>软件开发中的缓存并非多多益善，它有收益，也有风险。</p>
</blockquote>
<p>在软件开发中引入缓存的负面作用要明显大于硬件的缓存.因此需要足够的理由：</p>
<ul>
<li>为缓解 CPU 压力而做缓存</li>
<li>为缓解 I/O 压力而做缓存</li>
</ul>
<p>缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解 CPU 和 I/O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能（优先增强硬件）。</p>
<h5 id="缓存属性"><a class="markdownIt-Anchor" href="#缓存属性"></a> 缓存属性</h5>
<ul>
<li>
<p><strong>吞吐量</strong>：缓存的吞吐量使用 OPS 值（每秒操作数，Operations per Second，ops/s）来衡量，反映了对缓存进行<strong>并发</strong>读、写操作的效率，即缓存本身的工作效率高低。</p>
</li>
<li>
<p><strong>命中率</strong>：缓存的命中率即成功从缓存中返回结果次数与总请求次数的比值，反映了引入缓存的价值高低，命中率越低，引入缓存的收益越小，价值越低。</p>
<p>淘汰策略：</p>
<ul>
<li><strong>FIFO</strong> 优先淘汰最早进入被缓存的数据</li>
<li><strong>LRU</strong> 优先淘汰最久未被使用访问过的数据。 添加 List作为最近时间排序列表。访问时调整对象到开头，优先淘汰末尾</li>
<li><strong>LFU</strong>：优先淘汰最不经常使用的数据。 添加计数器，统计被访问次数。</li>
<li><strong>TinyLFU</strong> : LFU 的改进版,首先采用 Sketch (用少量的样本估计全体数，采用了基于“滑动时间窗”的热度衰减算法)对访问数据进行分析,牺牲准确性，减少计数器维护成本。</li>
<li><strong><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1512.00727.pdf">W-TinyLFU</a></strong> ：TinyLFU 的改进版本。应对稀疏突发访问(突然访问频率增高的数据)的问题。从整体上看是它是 LFU 策略，从局部实现上看又是 LRU 策略。</li>
</ul>
</li>
<li>
<p><strong>扩展功能</strong>：缓存除了基本读写功能外，还提供哪些额外的管理功能，譬如<strong>加载器</strong>、<strong>淘汰策略</strong>、<strong>失效策略</strong>、<strong>事件通知</strong>,<strong>并发级别</strong>，<strong>容量控制</strong>,<strong>引用方式</strong>,<strong>统计信息</strong>,<strong>持久化</strong>等等。以下为几款主流进程内缓存方案对比</p>
<table>
<thead>
<tr>
<th></th>
<th>ConcurrentHashMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问性能</td>
<td>最高</td>
<td>一般</td>
<td>良好</td>
<td>优秀 接近于 ConcurrentHashMap</td>
</tr>
<tr>
<td>淘汰策略</td>
<td>无</td>
<td>支持多种淘汰策略 FIFO、LRU、LFU 等</td>
<td>LRU</td>
<td>W-TinyLFU</td>
</tr>
<tr>
<td>扩展功能</td>
<td>只提供基础的访问接口</td>
<td>并发级别控制 失效策略 容量控制 事件通知 统计信息 ……</td>
<td>大致同左</td>
<td>大致同左</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>分布式支持</strong>：缓存可分为“进程内缓存”和“分布式缓存”两大类，前者只为节点本身提供服务，无网络访问操作，速度快但缓存的数据不能在各个服务节点中共享，后者则相反。</p>
<p>从访问的角度</p>
<ul>
<li><strong>复制式缓存</strong> (适合读多写少) ： 缓存中所有数据在分布式集群的每个节点里面都存在有一份副本，读取数据时无须网络访问，直接从当前节点的进程内存中返回</li>
<li><strong>集中式缓存</strong>: 集中式缓存的读、写都需要网络访问.集中式缓存的读、写都需要网络访问,访问性能较差。但进程独立。（Redis牛逼）</li>
</ul>
<p>从数据一致性角度（分为 AP 和 CP 两种类型）</p>
<ul>
<li>AP： redis  高性能高可用等特点，却并不保证强一致性</li>
<li>CP:保证强一致性的 ZooKeeper、Doozerd、Etcd ,不做缓存。通知、协调、队列、分布式锁等功能</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211227231252943.png" alt="image-20211227231252943" /></p>
<p>缺点：代码侵入性较大，需要由开发者承担多次查询、多次回填的工作，也不便于管理</p>
<h5 id="缓存风险"><a class="markdownIt-Anchor" href="#缓存风险"></a> 缓存风险</h5>
<p>缓存穿透</p>
<p>现象:如果查询的数据在数据库中根本不存在的话，缓存里自然也不会有，这类请求的流量每次都不会命中，每次都会触及到末端的数据库，缓存就起不到缓解压力的作用了，这种查询不存在数据的现象被称为缓存穿透。</p>
<p>出现原因：有可能是业务逻辑本身就存在的固有问题，也有可能是被恶意攻击的所导致</p>
<p>解决方式：</p>
<ul>
<li>在一定时间内对返回为空（异常不缓存）的 Key 值依然进行缓存</li>
<li>缓存之前设置一个布隆过滤器来解决</li>
</ul>
<p>缓存击穿</p>
<p>现象:缓存中某些热点数据忽然因某种原因失效了，譬如典型地由于超期而失效，此时又有多个针对该数据的请求同时发送过来，这些请求将全部未能命中缓存，都到达真实数据源中去，导致其压力剧增，</p>
<p>解决方式：</p>
<ul>
<li>加锁同步，以请求该数据的 Key 值为锁，使得只有第一个请求可以流入到真实的数据源中，其他线程采取阻塞或重试策略。</li>
<li>热点数据由代码来手动管理：缓存击穿是仅针对热点数据被自动失效才引发的问题，对于这类数据，可以直接由开发者通过代码来有计划地完成更新、失效，避免由缓存的策略自动管理。</li>
</ul>
<p>缓存雪崩</p>
<p>现象:大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存到达数据源，同样令数据源在短时间内压力剧增。</p>
<p>出现原因：大量数据一起加载进去</p>
<ul>
<li>系统有专门的缓存预热功能，也可能大量公共数据是由某一次冷操作加载的，</li>
<li>缓存服务由于某些原因崩溃后重启，此时也会造成大量数据同时失效，</li>
</ul>
<p>解决方式：</p>
<ul>
<li>提升缓存系统可用性，建设分布式缓存的集群。</li>
<li>启用透明多级缓存，各个服务节点一级缓存中的数据通常会具有不一样的加载时间，也就分散了它们的过期时间。</li>
<li>将缓存的生存期从固定时间改为一个时间段内的随机时间</li>
</ul>
<p>缓存污染</p>
<p>现象:缓存污染是指缓存中的数据与真实数据源中的数据不一致的现象。</p>
<p>原因:由开发者更新缓存不规范造成的,譬如事务异常缓存没有回滚</p>
<p>解决方式:更新缓存可以遵循设计模式Cache Aside(最简单、成本最低的 )、Read/Write Through、Write Behind Caching 等。</p>
<p>Cache Aside :</p>
<ul>
<li>读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。</li>
<li>写数据时，<strong>先写</strong>数据源，然后失效（<strong>而不是更新</strong>）掉缓存。</li>
</ul>
<p>在查询操作与回填缓存间隙时插入数据会出现数据不一致的情况。</p>
<p>透明多级分流系统这个小节看完了，整体从客户端出发到服务端之整个链路的缓冲，先前日常工作主要是后端，关注的更多是客户端上的缓存（Redis），相对来说狭隘许多。反而因为这种工作中很少感知的倒是加深了对“透明”的理解。</p>
<h2 id="架构安全性"><a class="markdownIt-Anchor" href="#架构安全性"></a> 架构安全性</h2>
<h3 id="认证"><a class="markdownIt-Anchor" href="#认证"></a> 认证</h3>
<blockquote>
<p>系统如何正确分辨出操作用户的真实身份</p>
</blockquote>
<p>一个架构安全性的经验原则：<strong>以标准规范为指导、以标准接口去实现。</strong></p>
<h4 id="标准"><a class="markdownIt-Anchor" href="#标准"></a> 标准</h4>
<p>主流的三种认证方式</p>
<ul>
<li><strong>通信信道上的认证</strong>：你和我建立通信连接之前认证，在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。</li>
<li><strong>通信协议上的认证</strong>：你请求获取我的资源之前认证，在互联网（Internet）场景中的典型是基于 HTTP 协议的认证。</li>
<li><strong>通信内容上的认证</strong>：你使用我提供的服务之前认证，在万维网（World Wide Web）场景中的典型是基于 Web 内容的认证。</li>
</ul>
<h5 id="http-认证"><a class="markdownIt-Anchor" href="#http-认证"></a> HTTP 认证</h5>
<p>面向传输协议，认证由HTTP服务器完成</p>
<p>认证方案</p>
<ol>
<li>
<p>未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码 ,在Header下加入</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">WWW-Authenticate</span><span class="punctuation">: </span>&lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br><span class="line"><span class="attribute">Proxy-Authenticate</span><span class="punctuation">: </span>&lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>客户端遵循服务端指定的认证方案，在请求资源的<strong>报文头</strong>中加入<strong>身份凭证信息</strong>，</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>&lt;认证方案&gt; &lt;凭证内容&gt;</span><br><span class="line"><span class="attribute">Proxy-Authorization</span><span class="punctuation">: </span>&lt;认证方案&gt; &lt;凭证内容&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>HTTP 认证框架提出认证方案是希望能把<strong>认证</strong>“要产生身份凭证”的目的<strong>与</strong>“具体如何产生凭证”的<strong>实现</strong>分离开来。无论客户端如何生成凭证的具体实现，都可以包容在 HTTP 协议预设的框架之内。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20211228231431347.png" alt="image-20211228231431347" /></p>
<p>HTTP 认证框架中的认证方案是允许自行扩展的。只要用户代理（User Agent，通常是浏览器，泛指任何使用 HTTP 协议的程序）能够识别这种私有的认证方案即可。</p>
<p>常见认证方案</p>
<ul>
<li>RFC 规范</li>
<li><strong>AWS4-HMAC-SHA256</strong>：亚马逊 AWS 基于 HMAC-SHA256 哈希算法的认证。</li>
<li><strong>NTLM</strong> / <strong>Negotiate</strong>：这是微软公司 NT LAN Manager（NTLM）用到的两种认证方式。</li>
<li><strong>Windows Live ID</strong>：微软开发并提供的“统一登入”认证。</li>
<li><strong>Twitter Basic</strong>：一个不存在的网站所改良的 HTTP 基础认证。</li>
</ul>
<h5 id="web-认证"><a class="markdownIt-Anchor" href="#web-认证"></a> Web 认证</h5>
<p>面向具体传输内容来设计，由系统本身提供。实现形式以登陆表单为主。</p>
<p>认证方案<strong>WebAuthn</strong> 分为两大部分 ：</p>
<p>注册:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102124653206.png" alt="image-20220102124653206" /></p>
<p>验证器可理解为用户设备上 TouchID、FaceID、实体密钥等认证设备的统一接口。</p>
<p>登陆</p>
<ol>
<li>用户访问登录页面，填入用户名后即可点击登录按钮。</li>
<li>服务器返回随机字符串 Challenge、用户 UserID。</li>
<li>浏览器将 Challenge 和 UserID 转发给验证器。</li>
<li>验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和用户信息，所以如果域名和用户都相同的话，就不需要生成密钥对了，直接以存储的私钥加密 Challenge，然后返回给浏览器。</li>
<li>服务端接收到浏览器转发来的被私钥加密的 Challenge，以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功。</li>
</ol>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<p>具体的安全框架提供的功能都很类似，大致包括以下四类：</p>
<ul>
<li>认证功能：以 HTTP 协议中定义的各种认证、表单等认证方式确认用户身份，这是本节的主要话题。</li>
<li>安全上下文：用户获得认证之后，要开放一些接口，让应用可以得知该用户的基本资料、用户拥有的权限、角色，等等。</li>
<li>授权功能：判断并控制认证后的用户对什么资源拥有哪些操作许可，这部分内容会放到“<a target="_blank" rel="noopener" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/authorization.html">授权</a>”介绍。</li>
<li>密码的存储与验证：密码是烫手的山芋，存储、传输还是验证都应谨慎处理，我们会放到“<a target="_blank" rel="noopener" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/confidentiality.html">保密</a>”去具体讨论。</li>
</ul>
<h3 id="授权"><a class="markdownIt-Anchor" href="#授权"></a> 授权</h3>
<blockquote>
<p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p>
</blockquote>
<p>授权所涉及到的问题</p>
<ul>
<li><strong>确保授权的过程可靠</strong>：</li>
<li><strong>确保授权的结果可控</strong></li>
</ul>
<h4 id="rbac"><a class="markdownIt-Anchor" href="#rbac"></a> RBAC</h4>
<blockquote>
<p>所有的访问控制模型，实质上都是在解决同一个问题：“<strong>谁</strong>（User）拥有什么<strong>权限</strong>（Authority）去<strong>操作</strong>（Operation）哪些<strong>资源</strong>（Resource）”。</p>
</blockquote>
<p>RBAC 将权限从用户身上剥离，改为绑定到“<strong>角色</strong>”（Role）上，将权限控制变为对“<strong>角色</strong>拥有操作哪些<strong>资源</strong>的<strong>许可</strong>”</p>
<p><strong>角色</strong>为的是解耦用户与权限之间的多对多关系</p>
<p><strong>许可</strong>为的是解耦操作与资源之间的多对多关系</p>
<p>RBAC 模型的演进</p>
<ul>
<li>RBAC-1 模型的角色权限继承关系</li>
<li>RBAC-1 模型的角色权限继承关系</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102181803608.png" alt="image-20220102181803608" /></p>
<p>数据权限基本只能由信息系统自主来来完成，并不存在能放之四海皆准的通用数据权限框架（日常工作用解决方案是添加行级权限）。</p>
<h4 id="oauth2"><a class="markdownIt-Anchor" href="#oauth2"></a> OAuth2</h4>
<p><strong>面向于解决第三方应用</strong>（Third-Party Application）的认证授权协议。</p>
<p>直接使用密码给第三方的缺点</p>
<ul>
<li><strong>密码泄漏</strong></li>
<li><strong>访问范围</strong></li>
<li><strong>授权回收</strong></li>
</ul>
<p>授权的流程</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102182458407.png" alt="image-20220102182458407" /></p>
<p><strong>授权方式</strong></p>
<p>授权码模式 （最严谨）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102182627220.png" alt="image-20220102182627220" /></p>
<p>授权过程</p>
<p>前置条件 第三方应用先要到授权服务器上进行注册。向认证服务器提供一个域名地址，从授权服务器中获取 ClientID 和 ClientSecret.</p>
<ol>
<li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI</li>
<li>授权服务器根据 ClientID 确认第三方应用的身份</li>
<li>用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，</li>
<li>第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。</li>
<li>授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌（访问令牌与刷新令牌）。</li>
</ol>
<p>缺点：</p>
<ul>
<li>第三方应用必须有应用服务器</li>
<li>繁复的调用过程</li>
</ul>
<p>隐式授权模式</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102191631758.png" alt="image-20220102191631758" /></p>
<p>相对于授权码模式省略掉了通过授权码换取令牌的步骤。授权服务器在得到用户授权后，直接返回了访问令牌。需要在注册时提供回调域名，此时会要求该域名与接受令牌的服务处于同一个域内。明确禁止发放刷新令牌。</p>
<p>密码模式</p>
<p>“第三方”视作是系统中与授权服务器相对独立的子模块，逻辑上与授权服务器仍同属一个系统。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102193026796.png" alt="image-20220102193026796" /></p>
<p>第三方应用拿着用户名和密码向授权服务器换令牌</p>
<p>客户端模式</p>
<p>客户端模式是指第三方应用以自己的名义，向授权服务器申请资源许可。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220102193149106.png" alt="image-20220102193149106" /></p>
<p>例如： 商品订单清理的定时服务，自动清理超过两分钟还未付款的订单时，直接以<strong>自己的名义</strong>向授权服务器申请一个能清理所有用户订单的授权。</p>
<h3 id="凭证"><a class="markdownIt-Anchor" href="#凭证"></a> 凭证</h3>
<blockquote>
<p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p>
</blockquote>
<h4 id="cookie-session"><a class="markdownIt-Anchor" href="#cookie-session"></a> Cookie-Session</h4>
<p>为了实现”让服务器至少有办法能够区分出发送请求的用户是谁“这个目的，<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6265#section-4.1">RFC 6265</a>规范定义了 HTTP 的状态管理机制，在 HTTP 协议中增加了 Set-Cookie 指令，该指令的含义是以<strong>键值对</strong>的方式向客户端发送一组信息，此信息将在此后一段时间内的每次 HTTP 请求中，以名为 Cookie 的 Header 附带着重新发回给服务端，以便服务端区分来自不同客户端的请求。</p>
<p>一个典型的 Set-Cookie 指令如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>id=icyfenix; Expires=Wed, 21 Feb 2020 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<p>收到该指令以后，客户端再对同一个域的请求中就会自动附带有键值对信息<code>id=icyfenix</code>，譬如以下代码所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/2.0</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>icyfenix.cn</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>id=icyfenix</span><br></pre></td></tr></table></figure>
<p>一般来说，系统会把状态信息保存在服务端，在 Cookie 里只传输的是一个无字面意义的、不重复的字符串，习惯上以<code>sessionid</code>或者<code>jsessionid</code>为名。服务器拿这个字符串为 Key，在内存中开辟一块空间，以 Key/Entity 的结构存储每一个在线用户的上下文状态，再辅以一些超时自动清理之类的管理措施。这种服务端的状态管理机制就是今天大家非常熟悉的 Session，Cookie-Session .</p>
<p>优势：</p>
<ul>
<li>完全规避掉上下文信息在传输过程中被泄漏和篡改的风险。</li>
<li>服务端有主动的状态管理能力</li>
</ul>
<p>分布式环境中的状态管理一定会受到 CAP 的局限，无论怎样都不可能完美。但如果只是解决分布式下的认证授权问题，并顺带解决少量状态的问题，就不一定只能依靠共享信息去实现。</p>
<h4 id="jwt"><a class="markdownIt-Anchor" href="#jwt"></a> JWT</h4>
<p>当服务器存在多个，客户端只有一个时，把状态信息存储在客户端，每次随着请求发回服务器去。</p>
<p>确保信息不被中间人篡改</p>
<p>使用方式</p>
<p>附在名为 Authorization 的 Header 发送给服务端，前缀在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>中被规定为 Bearer。</p>
<p>JWT 令牌结构</p>
<ul>
<li>
<p><strong>令牌头</strong>（Header），内容如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>它描述了令牌的类型（统一为 typ:JWT）以及令牌签名的算法，示例中 HS256 为 HMAC SHA256 算法的缩写，其他各种系统支持的签名算法可以参考https://jwt.io/网站所列。</p>
</li>
<li>
<p><strong>负载</strong>（Payload），这是令牌真正需要向服务端传递的信息。包括</p>
<ol>
<li>这个用户是谁</li>
<li>这个用户是谁</li>
</ol>
</li>
<li>
<p><strong>签名</strong> 确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失任何信息。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>令牌难以主动失效</strong></li>
<li><strong>相对更容易遭受重放攻击</strong></li>
<li><strong>只能携带相当有限的数据</strong></li>
<li><strong>必须考虑令牌在客户端如何存储</strong></li>
<li><strong>无状态也不总是好的</strong></li>
</ul>
<h3 id="保密"><a class="markdownIt-Anchor" href="#保密"></a> 保密</h3>
<blockquote>
<p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p>
</blockquote>
<p>保密是有成本的，追求越高的安全等级，就要付出越多的工作量与算力消耗。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/One-time_password">一次性密码</a>（One Time Password）具有绝对安全性，但是却需要提前安全地把密码或密码列表传达给对方。因而对于互联网没有任何的可行性。</p>
<p>客户端加密</p>
<p>为了保证信息不被黑客窃取而做客户端加密没有太多意义，客户端加密在意义在于可以最早时候消灭掉明文密码。</p>
<p>真正防御性的密码加密存储确实应该在服务端中进行，但这是为了防御服务端被攻破而批量泄漏密码的风险，并不是为了增加传输过程的安全。</p>
<p>密码存储和验证</p>
<h4 id="密码创建过程"><a class="markdownIt-Anchor" href="#密码创建过程"></a> 密码创建过程</h4>
<ol>
<li>
<p>用户在客户端注册，输入明文密码：<code>123456</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="number">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>客户端对用户密码进行简单哈希摘要</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_hash = MD5(password) <span class="comment">// e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了防御彩虹表攻击应加盐处理，客户端加盐只取固定的字符串即可，如实在不安心，最多用伪动态的盐值（“伪动态”是指服务端不需要额外通信可以得到的信息，譬如由日期或用户名等自然变化的内容，加上固定字符串构成）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_hash = MD5(MD5(password) + salt)  <span class="comment">// SALT = $2a$10$o5L.dWYEjZjaejOmN3x4Qu</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了预防暴力破解，建议使用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/index-html/p/frontend-slow-hash.html">慢哈希函数</a>。</p>
</li>
<li>
<p>盐值可以由<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">密码学安全伪随机数生成器</a>生成。、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line"><span class="type">byte</span> server_salt[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">36</span>];</span><br><span class="line">random.nextBytes(server_salt);   <span class="comment">// tq2pdxrblkbgp8vt8kbdpmzdh1w8bex</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将动态盐值混入客户端传来的哈希值再做一次哈希，产生出最终的密文，并和上一步随机生成的盐值一起写入到同一条数据库记录中。<code>BCryptPasswordEncoder</code>本身就会自动调用 CSPRNG 产生盐值，并将该盐值输出在结果的前 32 位之中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_hash = SHA256(client_hash + server_salt);  <span class="comment">// 55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span></span><br><span class="line">DB.save(server_hash, server_salt);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="验证的过程"><a class="markdownIt-Anchor" href="#验证的过程"></a> 验证的过程</h4>
<ol>
<li>
<p>客户端，用户在登录页面中输入密码明文：<code>123456</code>，经过与注册相同的加密过程，向服务端传输加密后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authentication_hash = MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>服务端，接受到客户端传输上来的哈希值，从数据库中取出登录用户对应的密文和盐值，采用相同的哈希算法，对客户端传来的哈希值、服务端存储的盐值计算摘要结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = SHA256(authentication_hash + server_salt);  <span class="comment">// 55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authentication = compare(result, server_hash) <span class="comment">// yes</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="传输"><a class="markdownIt-Anchor" href="#传输"></a> 传输</h3>
<p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p>
<p>现代密码学算法的三种主要用途：<strong>摘要</strong>、<strong>加密</strong>与<strong>签名</strong>。</p>
<h4 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h4>
<p>摘要的意义是在源信息<strong>不泄漏</strong>的前提下辨别其真伪。</p>
<p>理想的哈希算法都具备两个特性：</p>
<ul>
<li>易变性</li>
<li>不可逆性</li>
</ul>
<h4 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h4>
<p>加密与摘要的本质区别在于加密是可逆的，逆过程就是解密。</p>
<p>根据加密与解密是否采用同一个密钥，现代密码学算法可分为对称加密算法和非对称加密两大类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>常见实现</th>
<th>主要用途</th>
<th>主要局限</th>
</tr>
</thead>
<tbody>
<tr>
<td>哈希摘要</td>
<td>不可逆，即不能解密，所以并不是加密算法，只是一些场景把它当作加密算法使用。 易变性，输入发生 1 Bit 变动，就可能导致输出结果 50%的内容发生改变。 无论输入长度多少，输出长度固定（2 的 N 次幂）。</td>
<td>MD2/4/5/6、SHA0/1/256/512</td>
<td>摘要</td>
<td>无法解密</td>
</tr>
<tr>
<td>对称加密</td>
<td>加密是指加密和解密是一样的密钥。 设计难度相对较小，执行速度相对较块。 加密明文长度不受限制。</td>
<td>DES、AES、RC4、IDEA</td>
<td>加密</td>
<td>要解决如何把密钥安全地传递给解密者。</td>
</tr>
<tr>
<td>非对称加密</td>
<td>加密和解密使用的是不同的密钥。 明文长度不能超过公钥长度。</td>
<td>RSA、BCDSA、ElGamal</td>
<td>签名、传递密钥</td>
<td>性能与加密明文长度受限。</td>
</tr>
</tbody>
</table>
<h4 id="数字证书"><a class="markdownIt-Anchor" href="#数字证书"></a> 数字证书</h4>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD">公开密钥基础设施</a>借着数字证书认证中心（Certificate Authority，CA）将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。</p>
<p>权威的 CA 中心则应是可数的，“可数”意味着可以不通过网络，而是在浏览器与操作系统出厂时就预置好.</p>
<p>PKI 中采用的证书格式是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X.509">X.509 标准格式</a>，。一个数字证书具体包含以下内容：</p>
<ol>
<li>
<p><strong>版本号</strong>（Version）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version: 3 (0x2)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>序列号</strong>（Serial Number）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial Number: 04:00:00:00:00:01:15:4b:5a:c3:94</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>签名算法标识符</strong>（Signature Algorithm ID）：用于签发证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature Algorithm: sha1WithRSAEncryption</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>认证机构的数字签名</strong>（Certificate Signature）：这是使用证书发布者私钥生成的签名，以确保这个证书在发放之后没有被篡改过。</p>
</li>
<li>
<p><strong>认证机构</strong>（Issuer Name）： 证书颁发者的可识别名。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>有效期限</strong>（Validity Period）： 证书起始日期和时间以及终止日期和时间，指明证书在这两个时间内有效。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Validity</span><br><span class="line">	Not Before: Nov 21 08:00:00 2020 GMT</span><br><span class="line">	Not After : Nov 22 07:59:59 2021 GMT</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主题信息</strong>（Subject）：证书持有人唯一的标识符（Distinguished Name），这个名字在整个互联网上应该是唯一的，通常使用的是网站的域名。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject: C=CN, ST=GuangDong, L=Zhuhai, O=Awosome-Fenix, CN=*.icyfenix.cn</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>公钥信息</strong>（Public-Key）： 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数。</p>
</li>
</ol>
<h4 id="传输安全层"><a class="markdownIt-Anchor" href="#传输安全层"></a> 传输安全层</h4>
<p><strong>在计算机科学里，隔离复杂性的最有效手段（没有之一）就是分层，如果一层不够就再加一层</strong></p>
<p>在传输层之上、应用层之下加入专门的安全层来实现安全通信.</p>
<p>TLS</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20220103181308215.png" alt="image-20220103181308215" /></p>
<p>在传输性能上会有下降，但在功能上完全不会感知到有 TLS 的存在。建立在这层安全传输层之上的 HTTP 协议，就被称为“HTTP over SSL/TLS”，也即是大家所熟知的 HTTPS。</p>
<p>从上面握手协商的过程中我们还可以得知，HTTPS 并非不是只有“启用了 HTTPS”和“未启用 HTTPS”的差别，采用不同的协议版本、不同的密码学套件、证书是否有效、服务端/客户端对面对无效证书时的处理策略如何都导致了不同 HTTPS 站点的安全强度的不同，因此并不能说只要启用了 HTTPS 就必定能够安枕无忧。</p>
<h3 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h3>
<blockquote>
<p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p>
</blockquote>
<p>Java 里验证的标准做法：</p>
<ul>
<li>
<p>对于无业务含义的格式验证，可以做到预置。（在Bean中预设）</p>
</li>
<li>
<p>对于有业务含义的业务验证，可以做到重用，一个 Bean 被用于多个方法用作参数或返回值是很常见的，针对 Bean 做校验比针对方法做校验更有价值。利于集中管理，譬如统一认证的异常体系，统一做国际化、统一给客户端的返回格式等等。（使用自定义校验注解）</p>
</li>
<li>
<p>避免对输入数据的防御污染到业务代码，如果你的代码里面如果很多下面这样的条件判断，就应该考虑重构了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一些已执行的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (someParam == <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeExcetpion</span>(<span class="string">&quot;客官不可以！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利于多个校验器统一执行，统一返回校验结果，避免用户踩地雷、挤牙膏式的试错体验。</p>
</li>
</ul>
<p>实践时建议：</p>
<ul>
<li>
<p>自定义校验注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个用户的信息是无冲突的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * “无冲突”是指该用户的敏感信息与其他用户不重合，譬如将一个注册用户的邮箱，修改成与另外一个已存在的注册用户一致的值，这便是冲突</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;FIELD, METHOD, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = AccountValidation.NotConflictAccountValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotConflictAccount &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;用户名称、邮箱、手机号码与现存用户产生重复&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将不带业务含义的格式校验注解放到 Bean 的类定义之上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line">	<span class="meta">@NotEmpty(message = &quot;用户不允许为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;用户姓名不允许为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;1\\d&#123;10&#125;&quot;, message = &quot;手机号格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于“需要触发一部分校验”的非典型情况，启用分组校验来处理，设计一套“新增”、“修改”、“删除”这样的标识类，置入到校验注解的<code>groups</code>参数中去实现。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">酌客</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/">http://example.com/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">酌客的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://icyfenix.cn/images//logo-color.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/13/%E9%BB%91%E7%BE%A4%E6%99%96%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"><img class="prev-cover" data-lazy-src="https://www.synology.com/img/logo/logo_white.svg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑群晖 折腾笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E7%AC%94%E8%AE%B0/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20210905234112916.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">架构师笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/jpg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">酌客</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GayHub1"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的个人博客</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text"> 凤凰架构笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text"> 什么是“凤凰架构”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text"> 演进中的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 原始分布式时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E5%B7%A8%E7%9F%B3%E7%B3%BB%E7%BB%9F%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 单体(巨石)系统时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soa%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text"> SOA时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 微服务时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 后微服务时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9C%8D%E5%8A%A1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.6.</span> <span class="toc-text"> 无服务时代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-number">1.3.</span> <span class="toc-text"> 架构师的视角</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rpc%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text"> RPC（访问远程服务）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rest-%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text"> REST 设计风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text"> 事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acid"><span class="toc-number">1.4.0.1.</span> <span class="toc-text"> ACID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 本地事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 原子性持久性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 隔离性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 全局事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 共享事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cap"><span class="toc-number">1.4.4.1.</span> <span class="toc-text"> CAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#base"><span class="toc-number">1.4.4.2.</span> <span class="toc-text"> BASE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.3.</span> <span class="toc-text"> 柔性事务实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.4.4.3.1.</span> <span class="toc-text"> 可靠事件队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tcc-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.4.3.2.</span> <span class="toc-text"> TCC 事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#saga-%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.4.3.3.</span> <span class="toc-text"> SAGA 事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#at-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.3.4.</span> <span class="toc-text"> AT 事务模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text"> 透明多级分流系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 客户端缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.1.1.</span> <span class="toc-text"> 强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.1.2.</span> <span class="toc-text"> 协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E8%AF%86%E5%88%AB"><span class="toc-number">1.5.1.3.</span> <span class="toc-text"> 单个资源识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86"><span class="toc-number">1.5.1.4.</span> <span class="toc-text"> 多个资源标识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98dns"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 域名缓存（DNS ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E9%93%BE%E8%B7%AF"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 传输链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 内容分发网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 数据链路层负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.5.2.</span> <span class="toc-text"> 网络层负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.5.5.3.</span> <span class="toc-text"> 应用层负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.5.4.</span> <span class="toc-text"> 均衡策略与实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 服务端缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.6.0.1.</span> <span class="toc-text"> 缓存属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A3%8E%E9%99%A9"><span class="toc-number">1.5.6.0.2.</span> <span class="toc-text"> 缓存风险</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text"> 架构安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86"><span class="toc-number">1.6.1.1.</span> <span class="toc-text"> 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#http-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text"> HTTP 认证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#web-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text"> Web 认证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.2.</span> <span class="toc-text"> 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rbac"><span class="toc-number">1.6.2.1.</span> <span class="toc-text"> RBAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#oauth2"><span class="toc-number">1.6.2.2.</span> <span class="toc-text"> OAuth2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%AD%E8%AF%81"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 凭证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-session"><span class="toc-number">1.6.3.1.</span> <span class="toc-text"> Cookie-Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt"><span class="toc-number">1.6.3.2.</span> <span class="toc-text"> JWT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AF%86"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 保密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.1.</span> <span class="toc-text"> 密码创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.4.2.</span> <span class="toc-text"> 验证的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.6.5.1.</span> <span class="toc-text"> 摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86"><span class="toc-number">1.6.5.2.</span> <span class="toc-text"> 加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.5.3.</span> <span class="toc-text"> 数字证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%B1%82"><span class="toc-number">1.6.5.4.</span> <span class="toc-text"> 传输安全层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.6.6.</span> <span class="toc-text"> 校验</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="无题"><img data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/c0b418d39a3444e997791a823bc6bea3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/03/31/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2022-03-31T03:58:34.511Z" title="发表于 2022-03-31 11:58:34">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/13/2022/" title="2021"><img data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/IMG20210630233520.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021"/></a><div class="content"><a class="title" href="/2022/02/13/2022/" title="2021">2021</a><time datetime="2022-02-12T16:02:15.000Z" title="发表于 2022-02-13 00:02:15">2022-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/13/%E9%BB%91%E7%BE%A4%E6%99%96%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" title="黑群晖 折腾笔记"><img data-lazy-src="https://www.synology.com/img/logo/logo_white.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑群晖 折腾笔记"/></a><div class="content"><a class="title" href="/2022/02/13/%E9%BB%91%E7%BE%A4%E6%99%96%20%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/" title="黑群晖 折腾笔记">黑群晖 折腾笔记</a><time datetime="2022-02-12T16:02:15.000Z" title="发表于 2022-02-13 00:02:15">2022-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/" title="凤凰架构笔记摘要"><img data-lazy-src="https://icyfenix.cn/images//logo-color.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="凤凰架构笔记摘要"/></a><div class="content"><a class="title" href="/2021/12/01/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84%E7%AC%94%E8%AE%B0/" title="凤凰架构笔记摘要">凤凰架构笔记摘要</a><time datetime="2021-11-30T16:02:15.000Z" title="发表于 2021-12-01 00:02:15">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E7%AC%94%E8%AE%B0/" title="架构师笔记"><img data-lazy-src="https://cdn.jsdelivr.net/gh/GayHub1/images/img/image-20210905234112916.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="架构师笔记"/></a><div class="content"><a class="title" href="/2021/09/01/%E6%9E%B6%E6%9E%84%E5%B8%88%E7%AC%94%E8%AE%B0/" title="架构师笔记">架构师笔记</a><time datetime="2021-08-31T16:00:00.000Z" title="发表于 2021-09-01 00:00:00">2021-09-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By 酌客</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>粤ICP备20058715号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'hxN4EMnnWWFNeyk4xbNxQJT7-gzGzoHsz',
      appKey: 'lewYKS5k1rb7D5sVgI4QeTAx',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/GamerNoTitle/ValineCDN@master/',
      emojiMaps: {"bilibilitv2":"bilibilitv/[tv_doge].png","bilibilitv3":"bilibilitv/[tv_亲亲].png","bilibilitv4":"bilibilitv/[tv_偷笑].png","bilibilitv5":"bilibilitv/[tv_再见].png","bilibilitv6":"bilibilitv/[tv_冷漠].png","bilibilitv7":"bilibilitv/[tv_发怒].png","bilibilitv8":"bilibilitv/[tv_发财].png","bilibilitv9":"bilibilitv/[tv_可爱].png","bilibilitv10":"bilibilitv/[tv_吐血].png","bilibilitv11":"bilibilitv/[tv_呆].png","bilibilitv12":"bilibilitv/[tv_呕吐].png","bilibilitv13":"bilibilitv/[tv_困].png","bilibilitv14":"bilibilitv/[tv_坏笑].png","bilibilitv15":"bilibilitv/[tv_大佬].png","bilibilitv16":"bilibilitv/[tv_大哭].png","bilibilitv17":"bilibilitv/[tv_委屈].png","bilibilitv18":"bilibilitv/[tv_害羞].png","bilibilitv19":"bilibilitv/[tv_尴尬].png","bilibilitv20":"bilibilitv/[tv_微笑].png","bilibilitv21":"bilibilitv/[tv_思考].png","bilibilitv22":"bilibilitv/[tv_惊吓].png","bilibilitv23":"bilibilitv/[tv_打脸].png","bilibilitv24":"bilibilitv/[tv_抓狂].png","bilibilitv25":"bilibilitv/[tv_抠鼻].png","bilibilitv26":"bilibilitv/[tv_斜眼笑].png","bilibilitv27":"bilibilitv/[tv_无奈].png","bilibilitv28":"bilibilitv/[tv_晕].png","bilibilitv29":"bilibilitv/[tv_流汗].png","bilibilitv30":"bilibilitv/[tv_流泪].png","bilibilitv31":"bilibilitv/[tv_流鼻血].png","bilibilitv32":"bilibilitv/[tv_点赞].png","bilibilitv33":"bilibilitv/[tv_生气].png","bilibilitv34":"bilibilitv/[tv_生病].png","bilibilitv35":"bilibilitv/[tv_疑问].png","bilibilitv36":"bilibilitv/[tv_白眼].png","bilibilitv37":"bilibilitv/[tv_皱眉].png","bilibilitv38":"bilibilitv/[tv_目瞪口呆].png","bilibilitv39":"bilibilitv/[tv_睡着].png","bilibilitv40":"bilibilitv/[tv_笑哭].png","bilibilitv41":"bilibilitv/[tv_腼腆].png","bilibilitv42":"bilibilitv/[tv_色].png","bilibilitv43":"bilibilitv/[tv_调侃].png","bilibilitv44":"bilibilitv/[tv_调皮].png","bilibilitv45":"bilibilitv/[tv_鄙视].png","bilibilitv46":"bilibilitv/[tv_闭嘴].png","bilibilitv47":"bilibilitv/[tv_难过].png","bilibilitv48":"bilibilitv/[tv_馋].png","bilibilitv49":"bilibilitv/[tv_鬼脸].png","bilibilitv50":"bilibilitv/[tv_黑人问号].png","bilibilitv51":"bilibilitv/[tv_鼓掌].png","bilibili22332":"bilibili2233/[2233娘_卖萌].png","bilibili22333":"bilibili2233/[2233娘_吃惊].png","bilibili22334":"bilibili2233/[2233娘_吐魂].png","bilibili22335":"bilibili2233/[2233娘_喝水].png","bilibili22336":"bilibili2233/[2233娘_困惑].png","bilibili22337":"bilibili2233/[2233娘_大哭].png","bilibili22338":"bilibili2233/[2233娘_大笑].png","bilibili22339":"bilibili2233/[2233娘_委屈].png","bilibili223310":"bilibili2233/[2233娘_怒].png","bilibili223311":"bilibili2233/[2233娘_无言].png","bilibili223312":"bilibili2233/[2233娘_汗].png","bilibili223313":"bilibili2233/[2233娘_疑问].png","bilibili223314":"bilibili2233/[2233娘_第一].png","bilibili223315":"bilibili2233/[2233娘_耶].png","bilibili223316":"bilibili2233/[2233娘_郁闷].png","Heybox1":"Heybox/expression_cube.png","Heybox2":"Heybox/expression_cube_bingbujiandan.png","Heybox3":"Heybox/expression_cube_bizui.png","Heybox4":"Heybox/expression_cube_cangsang.png","Heybox5":"Heybox/expression_cube_dalian.png","Heybox6":"Heybox/expression_cube_doge.png","Heybox7":"Heybox/expression_cube_gandong.png","Heybox8":"Heybox/expression_cube_guai.png","Heybox9":"Heybox/expression_cube_gugu.png","Heybox10":"Heybox/expression_cube_han.png","Heybox11":"Heybox/expression_cube_hbi.png","Heybox12":"Heybox/expression_cube_heirenwenhao.png","Heybox13":"Heybox/expression_cube_huaji.png","Heybox14":"Heybox/expression_cube_jiayou.png","Heybox15":"Heybox/expression_cube_jingya.png","Heybox16":"Heybox/expression_cube_kaixin.png","Heybox17":"Heybox/expression_cube_ku.png","Heybox18":"Heybox/expression_cube_kun.png","Heybox19":"Heybox/expression_cube_kuqi.png","Heybox20":"Heybox/expression_cube_nu.png","Heybox21":"Heybox/expression_cube_penshui.png","Heybox22":"Heybox/expression_cube_qiliang.png","Heybox23":"Heybox/expression_cube_shengqi.png","Heybox24":"Heybox/expression_cube_shuijiao.png","Heybox25":"Heybox/expression_cube_tanqi.png","Heybox26":"Heybox/expression_cube_tanshou.png","Heybox27":"Heybox/expression_cube_tu.png","Heybox28":"Heybox/expression_cube_wa.png","Heybox29":"Heybox/expression_cube_weiqu.png","Heybox30":"Heybox/expression_cube_weixiao.png","Heybox31":"Heybox/expression_cube_wulianku.png","Heybox32":"Heybox/expression_cube_xia.png","Heybox33":"Heybox/expression_cube_xiaocry.png","Heybox34":"Heybox/expression_cube_xihuan.png","Heybox35":"Heybox/expression_cube_xuexi.png","Heybox36":"Heybox/expression_cube_yun.png","Heybox37":"Heybox/expression_cube_zan.png","Heybox38":"Heybox/expression_heyboxgirl.png","Heybox39":"Heybox/expression_heyboxgirl_v2.png","Heybox40":"Heybox/expression_heygirl.png","Heybox41":"Heybox/expression_heygirl_aidao.png","Heybox42":"Heybox/expression_heygirl_baipiaoguai.png","Heybox43":"Heybox/expression_heygirl_chi.png","Heybox44":"Heybox/expression_heygirl_chigua.png","Heybox45":"Heybox/expression_heygirl_eihei.png","Heybox46":"Heybox/expression_heygirl_haha.png","Heybox47":"Heybox/expression_heygirl_haixiu.png","Heybox48":"Heybox/expression_heygirl_henaicha.png","Heybox49":"Heybox/expression_heygirl_huaji.png","Heybox50":"Heybox/expression_heygirl_jing.png","Heybox51":"Heybox/expression_heygirl_jixialai.png","Heybox52":"Heybox/expression_heygirl_kaikele.png","Heybox53":"Heybox/expression_heygirl_ku.png","Heybox54":"Heybox/expression_heygirl_kujiuruhou.png","Heybox55":"Heybox/expression_heygirl_nielian.png","Heybox56":"Heybox/expression_heygirl_qiaokaixin.png","Heybox57":"Heybox/expression_heygirl_qiehua.png","Heybox58":"Heybox/expression_heygirl_rua.png","Heybox59":"Heybox/expression_heygirl_toukan.png","Heybox60":"Heybox/expression_heygirl_tu.png","Heybox61":"Heybox/expression_heygirl_wuyu.png","Heybox62":"Heybox/expression_heygirl_xihuan.png","Heybox63":"Heybox/expression_heygirl_yiwen.png","Heybox64":"Heybox/expression_heygirl_zhe.png","Heybox65":"Heybox/expression_heziji_1.png","Heybox66":"Heybox/expression_heziji_10.png","Heybox67":"Heybox/expression_heziji_11.png","Heybox68":"Heybox/expression_heziji_12.png","Heybox69":"Heybox/expression_heziji_13.png","Heybox70":"Heybox/expression_heziji_14.png","Heybox71":"Heybox/expression_heziji_15.png","Heybox72":"Heybox/expression_heziji_16.png","Heybox73":"Heybox/expression_heziji_17.png","Heybox74":"Heybox/expression_heziji_18.png","Heybox75":"Heybox/expression_heziji_19.png","Heybox76":"Heybox/expression_heziji_2.png","Heybox77":"Heybox/expression_heziji_20.png","Heybox78":"Heybox/expression_heziji_21.png","Heybox79":"Heybox/expression_heziji_22.png","Heybox80":"Heybox/expression_heziji_23.png","Heybox81":"Heybox/expression_heziji_24.png","Heybox82":"Heybox/expression_heziji_25.png","Heybox83":"Heybox/expression_heziji_26.png","Heybox84":"Heybox/expression_heziji_27.png","Heybox85":"Heybox/expression_heziji_28.png","Heybox86":"Heybox/expression_heziji_29.png","Heybox87":"Heybox/expression_heziji_3.png","Heybox88":"Heybox/expression_heziji_30.png","Heybox89":"Heybox/expression_heziji_31.png","Heybox90":"Heybox/expression_heziji_32.png","Heybox91":"Heybox/expression_heziji_4.png","Heybox92":"Heybox/expression_heziji_5.png","Heybox93":"Heybox/expression_heziji_6.png","Heybox94":"Heybox/expression_heziji_7.png","Heybox95":"Heybox/expression_heziji_8.png","Heybox96":"Heybox/expression_heziji_9.png","Sweetie-Bunny1":"Sweetie-Bunny/12311678.png","Sweetie-Bunny2":"Sweetie-Bunny/12311679.png","Sweetie-Bunny3":"Sweetie-Bunny/12311680.png","Sweetie-Bunny4":"Sweetie-Bunny/12311681.png","Sweetie-Bunny5":"Sweetie-Bunny/12311682.png","Sweetie-Bunny6":"Sweetie-Bunny/12311683.png","Sweetie-Bunny7":"Sweetie-Bunny/12311684.png","Sweetie-Bunny8":"Sweetie-Bunny/12311685.png","Sweetie-Bunny9":"Sweetie-Bunny/12311686.png","Sweetie-Bunny10":"Sweetie-Bunny/12311687.png","Sweetie-Bunny11":"Sweetie-Bunny/12311688.png","Sweetie-Bunny12":"Sweetie-Bunny/12311689.png","Sweetie-Bunny13":"Sweetie-Bunny/12311690.png","Sweetie-Bunny14":"Sweetie-Bunny/12311691.png","Sweetie-Bunny15":"Sweetie-Bunny/12311692.png","Sweetie-Bunny16":"Sweetie-Bunny/12311693.png","Sweetie-Bunny17":"Sweetie-Bunny/12311694.png","Sweetie-Bunny18":"Sweetie-Bunny/12311695.png","Sweetie-Bunny19":"Sweetie-Bunny/12311696.png","Sweetie-Bunny20":"Sweetie-Bunny/12311697.png","Sweetie-Bunny21":"Sweetie-Bunny/12311698.png","Sweetie-Bunny22":"Sweetie-Bunny/12311699.png","Sweetie-Bunny23":"Sweetie-Bunny/12311700.png","Sweetie-Bunny24":"Sweetie-Bunny/12311701.png","Sweetie-Bunny25":"Sweetie-Bunny/12311702.png","Sweetie-Bunny26":"Sweetie-Bunny/12311703.png","Sweetie-Bunny27":"Sweetie-Bunny/12311704.png","Sweetie-Bunny28":"Sweetie-Bunny/12311705.png","Sweetie-Bunny29":"Sweetie-Bunny/12311706.png","Sweetie-Bunny30":"Sweetie-Bunny/12311707.png","Sweetie-Bunny31":"Sweetie-Bunny/12311708.png","Sweetie-Bunny32":"Sweetie-Bunny/12311709.png","Sweetie-Bunny33":"Sweetie-Bunny/12311710.png","Sweetie-Bunny34":"Sweetie-Bunny/12311711.png","Sweetie-Bunny35":"Sweetie-Bunny/12311712.png","Sweetie-Bunny36":"Sweetie-Bunny/12311713.png","Sweetie-Bunny37":"Sweetie-Bunny/12311714.png","Sweetie-Bunny38":"Sweetie-Bunny/12311715.png","Sweetie-Bunny39":"Sweetie-Bunny/12311716.png","Sweetie-Bunny40":"Sweetie-Bunny/12311717.png","Snow-Miku1":"Snow-Miku/3583066@2x.png","Snow-Miku2":"Snow-Miku/3583067@2x.png","Snow-Miku3":"Snow-Miku/3583068@2x.png","Snow-Miku4":"Snow-Miku/3583069@2x.png","Snow-Miku5":"Snow-Miku/3583070@2x.png","Snow-Miku6":"Snow-Miku/3583071@2x.png","Snow-Miku7":"Snow-Miku/3583072@2x.png","Snow-Miku8":"Snow-Miku/3583073@2x.png","Snow-Miku9":"Snow-Miku/3583074@2x.png","Snow-Miku10":"Snow-Miku/3583075@2x.png","Snow-Miku11":"Snow-Miku/3583076@2x.png","Snow-Miku12":"Snow-Miku/3583077@2x.png","Snow-Miku13":"Snow-Miku/3583078@2x.png","Snow-Miku14":"Snow-Miku/3583079@2x.png","Snow-Miku15":"Snow-Miku/3583080@2x.png","Snow-Miku16":"Snow-Miku/3583081@2x.png","Snow-Miku17":"Snow-Miku/3583082@2x.png","Snow-Miku18":"Snow-Miku/3583083@2x.png","Snow-Miku19":"Snow-Miku/3583084@2x.png","Snow-Miku20":"Snow-Miku/3583085@2x.png","Snow-Miku21":"Snow-Miku/3583086@2x.png","Snow-Miku22":"Snow-Miku/3583087@2x.png","Snow-Miku23":"Snow-Miku/3583088@2x.png","Snow-Miku24":"Snow-Miku/3583089@2x.png","Snow-Miku25":"Snow-Miku/3583090@2x.png","Snow-Miku26":"Snow-Miku/3583091@2x.png","Snow-Miku27":"Snow-Miku/3583092@2x.png","Snow-Miku28":"Snow-Miku/3583093@2x.png","Snow-Miku29":"Snow-Miku/3583094@2x.png","Snow-Miku30":"Snow-Miku/3583095@2x.png","Snow-Miku31":"Snow-Miku/3583096@2x.png","Snow-Miku32":"Snow-Miku/3583097@2x.png","Snow-Miku33":"Snow-Miku/3583098@2x.png","Snow-Miku34":"Snow-Miku/3583099@2x.png","Snow-Miku35":"Snow-Miku/3583100@2x.png","Snow-Miku36":"Snow-Miku/3583101@2x.png","Snow-Miku37":"Snow-Miku/3583102@2x.png","Snow-Miku38":"Snow-Miku/3583103@2x.png","Snow-Miku39":"Snow-Miku/3583104@2x.png","Snow-Miku40":"Snow-Miku/3583105@2x.png","Mafumafu1":"Mafumafu/199749454.png","Mafumafu2":"Mafumafu/199749455.png","Mafumafu3":"Mafumafu/199749456.png","Mafumafu4":"Mafumafu/199749457.png","Mafumafu5":"Mafumafu/199749458.png","Mafumafu6":"Mafumafu/199749459.png","Mafumafu7":"Mafumafu/199749460.png","Mafumafu8":"Mafumafu/199749461.png","Mafumafu9":"Mafumafu/199749462.png","Mafumafu10":"Mafumafu/199749463.png","Mafumafu11":"Mafumafu/199749464.png","Mafumafu12":"Mafumafu/199749465.png","Mafumafu13":"Mafumafu/199749466.png","Mafumafu14":"Mafumafu/199749467.png","Mafumafu15":"Mafumafu/199749468.png","Mafumafu16":"Mafumafu/199749469.png","Mafumafu17":"Mafumafu/199749470.png","Mafumafu18":"Mafumafu/199749471.png","Mafumafu19":"Mafumafu/199749472.png","Mafumafu20":"Mafumafu/199749473.png","Mafumafu21":"Mafumafu/199749474.png","Mafumafu22":"Mafumafu/199749475.png","Mafumafu23":"Mafumafu/199749476.png","Mafumafu24":"Mafumafu/199749477.png"},
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script></div></body></html>